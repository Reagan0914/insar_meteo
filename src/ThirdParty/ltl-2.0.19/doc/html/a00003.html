<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LTL: Multidimensional Dynamic Arrays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="ltl_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LTL
   &#160;<span id="projectnumber">2.0.x</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Multidimensional Dynamic Arrays</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00216"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">The Class MArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">Statistical Functions for MArrays and Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00218"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">BLAS and LAPACK interface for MArrays</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00006"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">MArray I/O</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html">FFTW3 interface for MArrays</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00260"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">Gnuplot interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>


<h3><a class="anchor" id="marray_doc"></a>Multidimensional Dynamic Arrays</h3><div class="textblock"><a name="%4dultidimensional%20%44ynamic%20Arrays"></a> <a name="%4dArrays"></a><h1><a class="anchor" id="marray_terminology"></a>
Terminology</h1>
<p><a name="%4dArray%20terminology"></a></p>
<p><code>LTL</code> currently provides dynamic arrays of up to 7 dimensions (this is not a principle limitation. Higher dimensions are easily possible, I'm just too lazy to create higher dimensional versions of the needed methods. If you need them, feel free ...). The class' declaration is </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">class </span>MArray;</div>
</div><!-- fragment --><p><code>T</code> is the type stored in the array, and <code>N</code> is the number of dimensions, so, for example, </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; Image(1024,1024);</div>
</div><!-- fragment --><p> represents a 2 dimensional array holding 1024 times 1024 floats.</p>
<p>The terminology used is as follows: </p>
<ul>
<li><code>Rank:</code> the number of dimensions an array has. </li>
<li><code>Geometry:</code> The complete description of the 'shape' of an array. The array's rank, the length along each dimension, and the index range of each dimension. </li>
<li><code>Subarray:</code> A 'rectangular' sub-set of an Array having the same rank as the original array. It references the original array's data, so changing values of the subarray also changes these values in the original array. An example is a submatrix or a rectangular clipping of an image. </li>
<li><code>Slice:</code> The same as a Subarray except that its rank is smaller than the original array's rank. A row or column vector or a matrix is a good example or (part of) a 'plane' of a data cube. </li>
<li><code>Indexing an array</code>: Referring to an element or any arbitrary set of elements of an array. May yield a scalar value if indexing a single element, or an array-valued object when indexing a subarray/slice, or an 'index list' when indexing an arbitrary set of array elements. </li>
<li><code>Types and dimensions</code>: Unless specified otherwise, the template parameter <code>T</code> always refers to the type stored in an MArray, and the template parameter <code>N</code> always refers to the rank of the MArray.</li>
</ul>
<h1><a class="anchor" id="utility_classes"></a>
Utility classes</h1>
<h2><a class="anchor" id="class_range"></a>
The Class Range</h2>
<p><a name="%52ange"></a> <a name="class%20%52ange"></a></p>
<p>A <code>Range</code> is a utility object used in the context of <code>MArray</code> describing a range of integers used for creating arrays and indexing an array along one dimension. See the <code>Range</code> class reference documentation <a class="el" href="a00203.html">range.h</a>.</p>
<h2><a class="anchor" id="class_fixedvector"></a>
The Class FixedVector</h2>
<p><a name="%46ixed%20vector"></a> <a name="%43lass%20%46ixed%56ector"></a></p>
<p>This class is used to hold lists of indices for referencing arbitrary sets of elements of an MArray, e.g. the list of elements of a matrix which are <code>==0</code>.</p>
<h1><a class="anchor" id="class_marray"></a>
The Class MArray</h1>
<p><a name="%4dArray"></a> <a name="class%20%4dArray"></a></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">class </span>MArray;</div>
</div><!-- fragment --><p>This is LTL's main class. It represents a dynamic multidimensional array. The template parameters <code>T</code> specifies the type of objects stored in the array and the template parameter <code>N</code> specifies the <em>rank</em>, i.e. the number of dimensions. Therefore, <code>MArray&lt;float,2&gt;</code> represents a two-dimensional array holding floats. Note that only the number of dimensions of the MArray are templated. The actual size of each dimension is determined at runtime. Include &lt;<a class="el" href="a00194.html">ltl/marray.h</a>&gt; to use this class.</p>
<p><code>MArrays</code> feature subarrays (sometimes called views), slices, expression templated evaluation, and other features described below. The memory holding the actual data is reference counted, such that it is not freed until the last reference to the data by views or slices has been removed.</p>
<p>MArrays use <b>column-major</b> storage (fortran storage order). For matrices, this means that adjacent elements in memory hold values from the same row. For images, the first index refers to neighboring pixels in an image line. The first (leftmost) index has the smallest stride, the last (rightmost) index has the largest stride.</p>
<p>(Note: For not too large one or two-dimensional arrays (i.e. vectors and matrices) whose <em>size</em> is known at compile-time, you might prefer to use the classes FVector and FMatrix.)</p>
<h2><a class="anchor" id="creating_marrays"></a>
Creating MArrays</h2>
<p><a name="%4dArray%20constructors"></a> <a name="constructing%20%4dArrays"></a></p>
<p>See MArray::MArray for a full description of all constructors. Here we just give some code examples.</p>
<div class="fragment"><div class="line"><span class="comment">// 3-dim array with indices ranging from 1 to 128</span></div>
<div class="line">MArray&lt;float,3&gt; A(128,128,128);</div>
<div class="line"></div>
<div class="line"><span class="comment">// 2-dim array with indices -10,9,...,9,10 along dimension 1</span></div>
<div class="line"><span class="comment">//                      and  21,23,...,29  along dimension 2</span></div>
<div class="line">MArray&lt;float,2&gt; B( Range(-10,10), Range(21,29,2) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// new 3-dim array of same geometry as A</span></div>
<div class="line">MArray&lt;float,3&gt; C( A.shape() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// construct from expression</span></div>
<div class="line"><span class="comment">// new array gets the geometry of the expression</span></div>
<div class="line"><span class="comment">// the following 2 statements are absolutely equivalent</span></div>
<div class="line">MArray&lt;float,2&gt; D = -2.5 * log(B);</div>
<div class="line">MArray&lt;float,2&gt; D( -2.5 * log(B) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// construct an array without allocating memory. Memory can be allocated later</span></div>
<div class="line"><span class="comment">// using makeReference() or using assignment.</span></div>
<div class="line">MArray&lt;float,2&gt; E;</div>
</div><!-- fragment --><h2><a class="anchor" id="copy_constructor"></a>
The copy constructor and operator=()</h2>
<p><a name="%4dArray%20copy%20constructor"></a></p>
<p>The copy constructor </p>
<div class="fragment"><div class="line">MArray&lt;T,N&gt;::MArray( <span class="keyword">const</span> MArray&lt;T,N&gt;&amp; other );</div>
</div><!-- fragment --><p> Note that <em>other's</em> data are <em>NOT</em> copied. The copy constructor only <em>references</em> the other array's data. This is for allowing functions to return MArray objects in an efficient manner. Use <code>operator=</code> to <em>copy</em> the content of arrays.</p>
<p><code>MArray::operator=</code> is the <b>only</b> way to copy data from one <code>MArray</code> to another. All other methods (copy construction, initialization assignment) only create references (see <code>MArray::makeReference()</code>). <code>MArray::operator=</code> also allows for uninitialized lhs <code>MArrays</code> with <code>MArray</code> or expression rhs. In this case memory to hold the result is allocated and the <code>MArray</code> filled with a copy of the rhs <code>MAarray</code> or the evaluated values of the expression. If the lhs <code>MArray</code> already has memory allocated, then the lhs and rhs shapes have to be conformable.</p>
<h2><a class="anchor" id="uninit"></a>
Uninitialized MArrays</h2>
<p>It is legal to declare an <code>MArray</code> object without specifying the extents of its dimensions. Such <code>MArrays</code> are said to be uninitialized. They are useful as class members which are filled with an amount of data unknown at the time of construction. It is legal to call <code>operator=</code> and the copy-constructor on uninitialized arrays (so that a class instance containing an uninitialized <code>MArray</code> member can be passed and copied). It is not legal to assign an expression involving uninitialized operands. This should be caught when <code>LTL_RANGE_CHECKING</code> is used. If the lhs of an assignment is uninitialized but the rhs is not, the lhs will allocate memory to hold the result of evaluating the rhs. The other method of allocating memory to an uninitialized <code>MArray</code> is using <code>MArray::makeReference()</code>. In this case, the data is not copied, but the uninitialized <code>MArray</code> becomes a view of another <code>MArray's</code> data.</p>
<h2><a class="anchor" id="indexing_marrays"></a>
Indexing MArrays</h2>
<p><a name="%4dArray%20indexing"></a> <a name="%49ndexing%20%4dArrays"></a></p>
<p>Indexing an array can yield a single element (scalar) or a subarray/slice combination. Indexing is generally done using <code>operator()</code>. Providing only <code>int</code> arguments to <code>operator()</code> yields a scalar (or a reference to a scalar), any combination of <code>int</code> arguments and <code>Range</code> objects yields a subarray/slice. (See also the MArray class reference documentation on MArray::operator().) For flipping, rotating, reversing or transposing arrays have a look at MArray::reverse(), MArray::reverseSelf(), MArray::transpose(), and MArray::transposeSelf().</p>
<p><code>Range</code> objects can have non-unit strides, in which case the subarray/slice refers to every k-th element of the in the specified range along the original array dimension.</p>
<p>Note that if array-valued indexing is performed, the returned subarray or slice is referencing the original array's data. No copying is performed. Additionally, an array can be indexed using an IndexList object, which is a collection of an arbitrary set of array elements, returned by the function <code>where()</code>.</p>
<p>Indexing is always performed using <code>MArray::operator()</code>. Here are some examples:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; M( 100, 100 );</div>
<div class="line">MArray&lt;float,3&gt; C( 100, 100, 100 );</div>
<div class="line"><span class="keywordtype">float</span> a, b;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Indexing a single element</span></div>
<div class="line"><span class="comment">//    Note that we are using column major storage:</span></div>
<div class="line"><span class="comment">//    The first index refers to adjacent elements in memory, the last index</span></div>
<div class="line"><span class="comment">//    has the largest stride.</span></div>
<div class="line">a = M(34,23);</div>
<div class="line"></div>
<div class="line"><span class="comment">// scalar assignment</span></div>
<div class="line">M(12,87) = a;</div>
<div class="line"></div>
<div class="line"><span class="comment">// assignment of a scalar to a subarray (all elements = a)</span></div>
<div class="line"><span class="comment">// with non-unit strides (every second element in the first dimension</span></div>
<div class="line"><span class="comment">// and every third element in the second dimension</span></div>
<div class="line">M( Range(25,50,2), Range(25,50,3) ) = a;</div>
<div class="line"></div>
<div class="line"><span class="comment">// assignment of a slice to a subarray</span></div>
<div class="line">M( Range(25,50), Range(25,50) ) = C( 1, Range(75,100), Range(75,100) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// indexing a slice (the 5th column)</span></div>
<div class="line"><span class="comment">// and initializing a new array with the slice</span></div>
<div class="line"><span class="comment">// calls the copy-constructor NOT operator=, so that Column becomes</span></div>
<div class="line"><span class="comment">// a view of M (it references M&#39;s data)</span></div>
<div class="line">MArray&lt;float,1&gt; Column = M( 5, Range::all() );</div>
</div><!-- fragment --><p>Note that the index base of a subarray is reset to 1. Thus in the example above the submatrix has ranges 1..25 and 1..25. See method MArray&lt;T,N&gt;::setBase() if you need to change the base index.</p>
<p>Formally, we have the following variants of <code>MArray::operator()</code> </p>
<div class="fragment"><div class="line">T  MArray&lt;T,N&gt;::operator()( <span class="keywordtype">int</span> n1, ..., <span class="keywordtype">int</span> nN ) <span class="keyword">const</span></div>
<div class="line">T&amp; MArray&lt;T,N&gt;::operator()( <span class="keywordtype">int</span> n1, ..., <span class="keywordtype">int</span> nN )</div>
<div class="line">T  MArray&lt;T,N&gt;::operator()( <span class="keyword">const</span> FixedVector&amp; i ) <span class="keyword">const</span></div>
<div class="line">T&amp; MArray&lt;T,N&gt;::operator()( <span class="keyword">const</span> FixedVector&amp; i )</div>
</div><!-- fragment --><p> Index an <code>MArray</code> to obtain a single element of the array. The forms returning <code>T&amp;</code> are provided such that indexing expressions can be used on the lhs of assignments.</p>
<div class="fragment"><div class="line">MArray&lt;T,N&gt; MArray&lt;T,N&gt;::operator()( Range R1, ..., Range RN )</div>
</div><!-- fragment --><p> Return a subarray (an array having the same rank, but referring to a subset of the original array) of the original array. The returned <code>MArray</code> references the original array's data, so modifying the subarray's data modifies the original array's data.</p>
<p>Reference counting is performed on the actual data blocks, so the user does not have to worry about arrays going out of scope or being deliberately deleted while references still exits.</p>
<div class="fragment"><div class="line">MArray MArray&lt;T,N2&gt;::operator()( [any combination of <span class="keywordtype">int</span> and Range arguments] )</div>
</div><!-- fragment --><p>This actually has the simplified form </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> N2&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;some wild stuff...&gt;</div>
<div class="line">MArray&lt;T,N2&gt; operator()( [any combination of <span class="keywordtype">int</span> and Range args] )</div>
</div><!-- fragment --><p>Return a slice of the original array. The returned MArray references the original array's data, so modifying the subarray's data modifies the original array's data. Again, reference counting is performed.</p>
<p>Hereby the rank of the created array is reduced by 1 compared to the original array for every <code>int</code> argument given in the call (we say the dimension is "sliced away"). One could slice a 3-dimensional cube to get a matrix (using 1 <code>int</code> and 2 <code>Range</code> arguments) or a vector (using 2 <code>int</code> arguments and one <code>Range</code> argument) and so on ...</p>
<p>Additionally, there is the IndexList, which refers to an arbitrary set of elements:</p>
<div class="fragment"><div class="line">MArray&lt;float,3&gt; A(nx,ny,nz);</div>
<div class="line"></div>
<div class="line">A = ...;</div>
<div class="line"></div>
<div class="line"><span class="comment">// set all zeros to 1</span></div>
<div class="line">IndexList&lt;3&gt; list = where( A==0 );</div>
<div class="line">A[list] = 1;   <span class="comment">// or any conformable 1-d expression</span></div>
</div><!-- fragment --><p>Note that <code>operator()</code> is used to return a 1-d array of values by indexing an arbitrary geometry array with an index list, while <code>operator</code>[] is used to return a special object hoving an <code>operator=</code> so that one can assign a 1-d array to an arbitrary set of indices from an index list.</p>
<p>We have used the function </p>
<div class="fragment"><div class="line">IndexList&lt;N&gt; where( [some N-dim <span class="keywordtype">boolean</span> expression] );</div>
</div><!-- fragment --><p>Specifically, <code>MArray</code> provides</p>
<div class="fragment"><div class="line">MArray MArray&lt;T,1&gt;::operator()( <span class="keyword">const</span> IndexList&lt;N&gt;&amp; l )</div>
</div><!-- fragment --><p> Subscript an N-dimensional <code>MArray</code> with an list of indices, returning a 1 dimensional <code>MArray</code>.</p>
<div class="fragment"><div class="line">MArray IndexRef&lt;T,N&gt;::operator[]( <span class="keyword">const</span> IndexList&lt;N&gt;&amp; l )</div>
</div><!-- fragment --><p> Returns an <code>IndexRef&lt;T,N&gt;</code> object, which has an <code>operator=</code> implementation such that the the expression A[list] can be used on the lhs of an assignment.</p>
<h2><a class="anchor" id="marray_referencing"></a>
Referencing MArrays</h2>
<p><a name="%52eferencing"></a></p>
<p>Indexing <code>MArray</code> by subarray or slicing creates another <code>MArray</code> object that provides a view of the original <code>MArray's</code> memory, not a copy. We say the subarray or slice references the original MArray's memory.</p>
<p>In some cases, it is useful to create an <code>MArray</code> and make it explicity reference another's memory: </p>
<div class="fragment"><div class="line"><span class="comment">// make \c A reference \c B&#39;s memory. A and B have to have the same rank.</span></div>
<div class="line">MArray&lt;float,2&gt; B = ...;</div>
<div class="line">MArray&lt;float,2&gt; A;</div>
<div class="line">A.makeReference(B);</div>
</div><!-- fragment --><p> This will free the memory currently associated with <code>A</code> (if any) and make it reference the memory belonging to <code>B</code>.</p>
<p>It is possible to reference another <code>MArray</code> object's memory, but assigning it a different rank, for example interpreting a MxN matrix as a vector of length MxN. This requires the matrix to have contiguous storage (<code>isStorageContiguous()</code> must be true) and this disallows some products of subarrays and slices from being treated in this way. The above example would read: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MArray::makeReferenceWithDims( <span class="keyword">const</span> MArray&amp; other, <span class="keyword">const</span> <span class="keywordtype">int</span>* dims );</div>
<div class="line"></div>
<div class="line">MArray&lt;float,2&gt; matrix(M,N);</div>
<div class="line">MArray&lt;float,1&gt; vector;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* dims = {M, N};</div>
<div class="line">vector.makeReferenceWithDims( matrix, dims );</div>
</div><!-- fragment --><h2><a class="anchor" id="marray_assignment"></a>
Assignment</h2>
<p><a name="Assignment"></a></p>
<p>Assignment to array elements or to whole arrays (or subarrays) is straightforward. Assignment is always possible from a scalar expression, in which case the whole left-hand side (lhs) (if it is not a scalar reference itself) is filled with the scalar value, i.e. <code>A=0</code>; will set all elements of array <code>A</code> to <code>0</code>.</p>
<p>Assignment to an array (no matter if it is a subarray or a slice of another array or not) is possible from scalars, arrays (or subarrays or slices), and from array-valued expressions. In the case that the rhs of the assignment is array-valued, the lhs and the rhs have be conformable. <a class="el" href="a00003.html#conformability">Array and Expression Conformability</a>, for further details.</p>
<p>A few examples: </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A(n1,n2), B(n1,n2), C(n1,n2);</div>
<div class="line">A=0; <span class="comment">// all of A = 0;</span></div>
<div class="line">B=C=2.222;</div>
<div class="line"></div>
<div class="line">A = (sin(B) + C/2) * exp( -(C*C) ); <span class="comment">// assignment from expression</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// assignment to slice from expression with slice</span></div>
<div class="line">A( 2, Range(10:20) ) = 5 + log( B( 4, Range(1:10) ) / 3. );</div>
</div><!-- fragment --><p>The only important thing to note here is that assignment copies the data while initialization/construction from another array object only references the other array's data.</p>
<p>To ease initialization of arrays, a handy method is provided using a comma-delimited list of values: <a name="%49nitializing%20%4dArrays"></a></p>
<div class="fragment"><div class="line">MArray A(4,4);</div>
<div class="line"></div>
<div class="line">A = 1,  0,  0,  0,</div>
<div class="line">    0, -1,  0,  0,</div>
<div class="line">    0,  0, -1,  0,</div>
<div class="line">    0,  0,  0, -1;</div>
</div><!-- fragment --><p>Note, though, that since <code>MArrays</code> have fortran storage order (column major storage), the above actually fills the array with the transpose of what's written there.</p>
<h2><a class="anchor" id="element-types"></a>
Element types of MArrays</h2>
<p><a name="%4dArray%20element-types"></a></p>
<p>As of LTL version 1.0, arbitrary data types are supported as <code>MArray</code> elements, as long as a default constructor and a copy constructor are provided. Support for such data types in LTL versions 2.0 and later is much more complete. In LTL 2.0 and later, if the data type provides arithmetic operators and/or mathematical operators, then expression templates will also work out of the box. In particular, LTL 2.0 and later supports <code>MArrays</code> of <code>complex&lt;float&gt;</code> and <code>complex&lt;double&gt;</code>, <code>FVector</code>, and <code>FMatrix</code> with full expression template support and mathematical operations and operators:</p>
<p>The follwing code fragments show some examples of what's allowed in LTL 2.0 and later:</p>
<div class="fragment"><div class="line"><span class="comment">// MArray&lt;FVector&gt; example:</span></div>
<div class="line">MArray&lt;FVector&lt;float,3&gt;, 1&gt; A(10), B(10);</div>
<div class="line">FVector&lt;float,3&gt; v, w, zero;</div>
<div class="line">v = 1,2,3;   w = 3,6,9;    zero = 0;</div>
<div class="line">A = 2.0f*v + w;</div>
<div class="line">B = A+2*A;</div>
<div class="line">B = 2*A-2*w;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Gradient example showing mixed expressions:</span></div>
<div class="line">MArray&lt;float,2&gt; A(10,10);                 <span class="comment">// a scalar field</span></div>
<div class="line">MArray&lt;FVector&lt;float,2&gt;,2&gt; B(10,10);      <span class="comment">// it&#39;s gradient is a vector field</span></div>
<div class="line">A = ...</div>
<div class="line">B = convolve(A,grad2D());</div>
</div><!-- fragment --><h2><a class="anchor" id="marray_iterators"></a>
Iterators</h2>
<p><a name="%49terators"></a> <a name="%4dArray%20iterators"></a></p>
<p>Iterators are "generalized pointers" to the elements of an array of arbitrary geometry, providing two operations, namely dereferencing via <code>operator*</code> (returning the value of the element currently pointed to or a reference to it for use on the rhs) and moving the "pointer" to the next element via <code>operator++</code>.</p>
<p>They are very useful for implementing the probably most common pattern applied to arrays in scientific computing - doing something for all elements of an array (and thus also provide a basis to the whole expression template business). For example, calculating the mean value of an array is an operation which is well defined for any array shape. Why should one have to care about the particular array geometry in the implementation? The answer are iterator objects.</p>
<p>Here's a naive implementation of the general-purpose average:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keywordtype">int</span> N&gt;</div>
<div class="line">T <a class="code" href="a00240.html#ga75e7b33ef3bc491bf244accc57adc439">average</a>( <span class="keyword">const</span> MArray&lt;T,N&gt;&amp; A )</div>
<div class="line">{</div>
<div class="line">   T <a class="code" href="a00237.html#gab581adc068d0fe50a12f817eeae5cb78">sum</a>(0);</div>
<div class="line">   MArray&lt;T,N&gt;::const_iterator i=A.begin();</div>
<div class="line">   <span class="keywordflow">for</span>( ; !i.done(); ++i )</div>
<div class="line">      <a class="code" href="a00237.html#gab581adc068d0fe50a12f817eeae5cb78">sum</a> += *i;</div>
<div class="line">   <span class="keywordflow">return</span> <a class="code" href="a00237.html#gab581adc068d0fe50a12f817eeae5cb78">sum</a>/A.nelements();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Usually, one will have much more complicated stuff within the loop... But the example above is enough to get the idea.</p>
<p>As a neat extra feature, the iterators are compatible with those known from the Standard Template Library (STL). So you can use the STL algorithms on <code>MArrays</code>. The only thing to know here is that the standard iterators in the LTL are only models of <code>forward_iterators</code>. That is because they have to deal with arbitrary array geometries such as slices and subarrays with non-unit strides etc., so accessing the n-th element is impossible (in constant time, which we REALLY should).</p>
<p>That's why we provide a second set of iterators which are true <code>random_access_iterators</code>, but only under the precondition that the associated <code>MArray</code> object has a contiguous memory layout (which is always true for newly allocated arrays and for suitable subarrays or slices). The random-access iterators are then simply pointers to the array's data, aka objects of type <code>T*</code>.</p>
<p>The following methods and suitable typedefs for the iterator-types are provided in the class <code>MArray:</code> </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keyword">class </span>MArray</div>
<div class="line">{</div>
<div class="line">      ...</div>
<div class="line"></div>
<div class="line">      <span class="comment">// STL definitions</span></div>
<div class="line">      <span class="keyword">typedef</span> T                     value_type;</div>
<div class="line">      <span class="keyword">typedef</span> T&amp;                    reference;</div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;              const_reference;</div>
<div class="line">      <span class="keyword">typedef</span> T*                    pointer;</div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> T*              const_pointer;</div>
<div class="line">      <span class="keyword">typedef</span> <span class="keywordtype">size_t</span>                size_type;</div>
<div class="line">      <span class="keyword">typedef</span> MArrayIter&lt;T,N&gt;       iterator;</div>
<div class="line">      <span class="keyword">typedef</span> MArrayIterConst&lt;T,N&gt;  const_iterator;</div>
<div class="line">      ...</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">iterator MArray&lt;T,N&gt;::begin();</div>
<div class="line">const_iterator MArray&lt;T,N&gt; begin () <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Return an iterator for the <code>MArray</code>. These are models of the STL <code>forward_iterator</code> iterator category. The <code>iterator</code> object itself offers the following methods: </p>
<div class="fragment"><div class="line">iterator&amp; operator++();</div>
<div class="line">T operator*() <span class="keyword">const</span>;</div>
<div class="line">T&amp; operator*();</div>
<div class="line"><span class="keywordtype">bool</span> operator==( iterator&amp; other );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> done();    <span class="comment">//more efficient than ==end</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">iterator MArray&lt;T,N&gt;::end () </div>
</div><!-- fragment --><p> Return an iterator pointing past the end of the <code>MArray</code>. Used with <code>operator==</code> to check for end of iteration. <code>iterator.done()</code> is more efficient, though.</p>
<div class="fragment"><div class="line">T* MArray&lt;T,N&gt;::beginRA();</div>
<div class="line">T* MArray&lt;T,N&gt;::endRA ();</div>
</div><!-- fragment --><p> Return STL compatible random access iterators. Works only under the precondition that the associated <code>MArray</code> object has a contiguous memory layout (which is always true for newly allocated arrays and for suitable subarrays or slices).</p>
<p>With these STL-style random access iterators you can write things like (or anything else using STL algorithms): </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line">MArray A = ...;</div>
<div class="line">std::sort( A.beginRA(), A.endRA() );</div>
</div><!-- fragment --><h2><a class="anchor" id="index_iterators"></a>
Index Iterators</h2>
<p><a name="%49ndex%20%49terators"></a> <a name="%4dArray%20index%20iterators"></a></p>
<p>In many situations one has to fill arrays with values that are expressed as functions of "coordinates" within the array, or more generally, as functions of the array's indices. Imagine setting up initial conditions for a PDE, e.g. a circular sine wave on a 2-d surface. For this purpose index iterators are provided. They behave much like normal iterators, but instead of returning the array's value they return the indices of the element they currently point to. An index iterator can be obtained from an <code>MArray</code> by calling <code>indexBegin()</code>:</p>
<div class="fragment"><div class="line">MArray&lt;T,N&gt; A( ... );</div>
<div class="line">MArray&lt;T,N&gt;::IndexIterator i = A.indexBegin();</div>
</div><!-- fragment --><div class="fragment"><div class="line">IndexIterator MArray&lt;T,N&gt;::indexBegin (); </div>
</div><!-- fragment --><p> Return an <code>IndexIterator</code> for the current <code>MArray</code>.</p>
<p>An index iterator always iterates over the index ranges of the array it was created from. They are used in the same way as normal iterators, except that they have some additional methods and no <code>operator*</code>:</p>
<div class="fragment"><div class="line">FixedVector I = i(); <span class="comment">// get index</span></div>
<div class="line"><span class="keywordtype">int</span> x = i(1);        <span class="comment">// get index in first dimension</span></div>
<div class="line"><span class="keywordtype">int</span> y = i(2);        <span class="comment">// get index in second dimension</span></div>
</div><!-- fragment --><p>Mostly you will prefer to use the 'automatic' version of the index iterators directly in expressions rather than creating an index iterator by hand and writing out the loop, <a class="el" href="a00003.html#array_expressions">Array Expressions</a>. These look like an ordinary function in the expression. The "function" simply evaluates to the index of the current element during elementwise evaluation of the expression, e.g.</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; E(10,10);</div>
<div class="line">E = <a class="code" href="a00253.html#ga533f80e8825c730acf0e024657739813">indexPosInt</a>(E,1)==<a class="code" href="a00253.html#ga533f80e8825c730acf0e024657739813">indexPosInt</a>(E,2); <span class="comment">// 10x10 unity matrix</span></div>
</div><!-- fragment --><p>While <code><a class="el" href="a00253.html#ga533f80e8825c730acf0e024657739813">indexPosInt()</a></code> evaluates to an <code>int</code>, there are also spcialized versions that return <code>float</code> and <code>double</code> values, <code><a class="el" href="a00253.html#ga37dbd6e17cf900405efb3479409adc0a">indexPosFlt()</a></code> and <code><a class="el" href="a00253.html#ga966fb96d100d1773af124303094eda2d">indexPosDbl()</a></code>, respectively. These are provided for convenience to avoid having to use cast expressions too frequently.</p>
<h2><a class="anchor" id="array_expressions"></a>
Array Expressions</h2>
<p><a name="%4dArray%20%45xpressions"></a> <a name="%45xpressions"></a> <a name="%45xpression%20templates"></a></p>
<p>Array expressions are expressions involving at least one array-valued operand and returning an array-valued result. They are mostly defined by elementwise application of the operations to the operands (Adding matrices is an example. In contrast, matrix multiplication is an array expression which is not simply defined elementwise).</p>
<p>LTL uses a technique called expression templates (See Todd Veldhuizen's Techniques for Scientific C++; <a href="http://extreme.indiana.edu/~tveldhui/papers/techniques/">http://extreme.indiana.edu/~tveldhui/papers/techniques/</a> ) to evaluate such expressions. This technique is used to overcome the problem that would occur if we were simply overloading the functions and operators for arrays, namely that every function or operator would generate a temporary array object to store its result (and that the loop over all elements would be executed once for each operation). In LTL expression evaluation <em>will not generate any temporaries or multiple loops</em>. That means that code like</p>
<div class="fragment"><div class="line">MArray&lt;float,1&gt; A(...), B(...), C(...), D(...);</div>
<div class="line">D = 2*C + log(A*B);</div>
</div><!-- fragment --><p>will be transformed at <em>compile time</em> to something resembling</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=start; i&lt;=end; ++i )</div>
<div class="line">   D(i) = 2*C(i) + log(A(i)*B(i));</div>
</div><!-- fragment --><p>In reality this will involve iterators instead of direct indices which will work for any dimensionality and take advantage of some further optimizations that can be performed in special cases, like when the arrays have contiguous memory layout or make use of common strides etc., but the principle is like in the example above. Additionally, the loop gets unrolled automatically by the LTL, and we make sure that the compiler does not assume too loose aliasing constraints on the pointers involved.</p>
<p>As a special bonus, we make use of the vector units present in newer processors (MMX/SSE/SSE2 in x86 compatible processors, Altivec in PowerPC processors). If this feature is enabled (see below), and if all operations used in an expression have vector implementations (on the given hardware platform), LTL will automatically evaluate the loop using the vector unit. This can significantly speed up code execution (espcially on PowerPCs, less so but still worth while on x86).</p>
<p>An expression can contain any mix of the following operands:</p>
<ul>
<li>an array or subarray/slice of any type. Expressions which contain a mixture of array types are handled through standard C++ type-promotion; All array operands in an expression must be conformable, i.e. have the same rank and the same length along each dimension. The index range may differ. <a class="el" href="a00003.html#conformability">Array and Expression Conformability</a>. </li>
<li>operations listed in <a class="el" href="a00003.html#array_operations">Array Valued Operations</a>, and <a class="el" href="a00003.html#scalar_operations">Full Reductions</a>, including user defined functions as discussed in <a class="el" href="a00003.html#user_operations">User Defined Operations</a>. </li>
<li>scalars of type <code>bool</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>long double</code> (if supported on the platform), or <code>complex&lt;T&gt;</code>, </li>
<li><code>scalars</code> of the same usr-defined type as the MArrays in the expression (e.g. <code>FVector</code> if we are dealing with <code>MArray&lt;FVector&gt;</code>), </li>
<li><code>indexPos{Int</code>,Flt,Dbl}() expressions, </li>
<li><code>merge()</code> expressions, </li>
<li><code>apply()</code> expressions, </li>
<li><code>convolve()</code> expressions, </li>
<li><code>partial</code> and full reductions, </li>
<li>parentheses and other expressions, naturally</li>
</ul>
<p>If the elements of the <code>MArrays</code> in the expression are of different types, regular C/C++ type promotion rules apply as long as the elements are built-in C++ types. When using user-defined types as elements of <code>MArrays</code>, expressions will still work, but the element types will have to be compatible. As a side effect, when scalars (literals) appear in expressions, these literals will NOT take part in the type promotion process. So while <code>MArray&lt;float&gt;</code> + <code>Marray&lt;double&gt;</code> will be promoted to double, the expression <code>MArray&lt;int&gt;</code> + <code>1.0f</code> will not.</p>
<p><code>indexPosInt( const MArray&lt;T,N&gt;&amp; A, const int dim )</code> expressions are special functions which will evaluate to the index position along dimension <code>dim</code> in the <code>MArray A</code> during each step in the evaluation of the expression.</p>
<p>To fill a 2-d array with a circular sine wave:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A( Range(-100,100), Range(-100,100) );</div>
<div class="line">A = sin( sqrt(<a class="code" href="a00253.html#ga37dbd6e17cf900405efb3479409adc0a">indexPosFlt</a>(A,1)*<a class="code" href="a00253.html#ga37dbd6e17cf900405efb3479409adc0a">indexPosFlt</a>(A,1) +</div>
<div class="line">              <a class="code" href="a00253.html#ga37dbd6e17cf900405efb3479409adc0a">indexPosFlt</a>(A,2)*<a class="code" href="a00253.html#ga37dbd6e17cf900405efb3479409adc0a">indexPosFlt</a>(A,2)) );</div>
</div><!-- fragment --><p><code>merge( bool_expr, true_case, false_case )</code> (see <a class="el" href="a00256.html">Merge Expressions</a>) expressions are a generalization of the <code>A ? T : F</code> pattern. For each element <code>bool_expr</code> is evaluated. If it is true the result is the result of the evaluation of <code>true_case</code>, if not, the result is the result of the evaluation of <code>false_case</code>. When calculating <code>1/A</code> for example:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A( nx, ny ), B( nx, ny );</div>
<div class="line">...</div>
<div class="line">B = merge( A != 0.0, 1.0/A, 0.0 );</div>
</div><!-- fragment --><p>If you have a functor object (any object defining <code>operator()</code>), you may use it in any expression using <code>apply()</code>: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>myfunc</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">float</span> operator()( <span class="keywordtype">float</span> x )</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// do something with x</span></div>
<div class="line">      <span class="keywordflow">return</span> y;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">myfunc f;</div>
<div class="line"></div>
<div class="line">MArray&lt;float,1&gt; A(N), B(N);</div>
<div class="line">A = ... ;</div>
<div class="line">B = apply( f, A );</div>
</div><!-- fragment --><p>An overloaded version of <code>apply()</code> taking 2 arguments is also provided for applying binary functors.</p>
<h2><a class="anchor" id="array_operations"></a>
Array Valued Operations</h2>
<p><a name="Array%20%56alued%20%4fperations"></a></p>
<p>The following binary operators and functions can be used in any array expression:</p>
<div class="fragment"><div class="line">+, -, *, /,</div>
<div class="line">&amp;&amp;, ||,</div>
<div class="line">&amp;, |, ^,</div>
<div class="line">%,</div>
<div class="line">&gt;, &lt;, &gt;=, &lt;=, !=, ==,</div>
<div class="line">pow(), fmod(), atan2()</div>
</div><!-- fragment --><p>and, for convenience, </p>
<div class="fragment"><div class="line">+=, -=, *=, /=,</div>
<div class="line">&amp;=, !=, ^=</div>
<div class="line">\endocde</div>
<div class="line"></div>
<div class="line">The following array valued unary operators and functions can be used</div>
<div class="line">in any array expression taking arrays and/or expressions as operands:</div>
<div class="line"></div>
<div class="line">\code</div>
<div class="line">+, -, !, ~</div>
<div class="line">sin(), cos(), tan(),</div>
<div class="line">asin(), acos(), atan(),</div>
<div class="line">sinh(), cosh(), tanh(),</div>
<div class="line">exp(), log(), log10(),</div>
<div class="line">sqrt(),</div>
<div class="line">fabs(),</div>
<div class="line">floor(), ceil(), round()</div>
</div><!-- fragment --><p>Along with some additional handy functions:</p>
<div class="fragment"><div class="line"><span class="comment">// compute integer powers by multiplication</span></div>
<div class="line">pow2(), pow3(), pow4(), pow5(), pow6(), pow7(), pow8()</div>
</div><!-- fragment --><p>If your system provides IEEE math functions, they also can be used:</p>
<div class="fragment"><div class="line"><span class="comment">// IEEE math functions</span></div>
<div class="line">asinh(), acosh(), atanh(), <span class="comment">// inverse hyperbolic</span></div>
<div class="line">cbrt(),                    <span class="comment">// cube root</span></div>
<div class="line">expm1(), log1p()           <span class="comment">// exp(x)-1, log(1+x)</span></div>
<div class="line">erf(), erfc(),             <span class="comment">// error-func and complementary. erf</span></div>
<div class="line">j0(), j1(), y0(), y1(),    <span class="comment">// 1st and 2nd kind bessel functions</span></div>
<div class="line">lgamma(),                  <span class="comment">// natural log of gamma function</span></div>
<div class="line">rint()                     <span class="comment">// rounding etc.</span></div>
</div><!-- fragment --><p>If your compiler and math library fully support the <code>complex&lt;T&gt;</code> type, you may also see the following functions defined:</p>
<div class="fragment"><div class="line">abs(), arg(), norm(), imag(), real(), conj().</div>
</div><!-- fragment --><p>As well as the standard trigonometric, transcendental, exponential, and log functions that extend naturally to complex numbers.</p>
<p>See your system's man pages to see which of the above functions are available and for complete descriptions.</p>
<p>LTL also provides two fucntions to (moderately) safely compare floating point numbers follwoing Knuth, D.E., The art of computer programming, Vol II. </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> feq( <span class="keyword">const</span> <span class="keywordtype">float</span> a, <span class="keyword">const</span> <span class="keywordtype">float</span> b )</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">float</span> ab = fabsf(a-b);</div>
<div class="line">   <span class="keywordflow">return</span>  (ab &lt;= 1e-7f*fabsf(a)) || (ab &lt;= 1e-7f*fabsf(b));</div>
<div class="line">}</div>
</div><!-- fragment --><p> and the negation <code>fneq(a,b)</code>. These can be used in expressions like all other math functions listed above.</p>
<p>Additionally one has the merge() expression and the <code>indexPos()</code> functions described in <a class="el" href="a00003.html#array_expressions">Array Expressions</a>, and the partial reductions described in <a class="el" href="a00003.html#partial_reductions">Partial Reductions</a>.</p>
<h2><a class="anchor" id="scalar_operations"></a>
Full Reductions</h2>
<p><a name="%53calar%20%56alued%20%4fperations"></a> <a name="%46ull%20%52eductions"></a></p>
<p>The following scalar valued functions (also called full reductions) are provided for <code>array and expression</code> arguments (See <a class="el" href="a00217.html">Statistical Functions for MArrays and Expressions</a> reference documentation):</p>
<div class="fragment"><div class="line"><span class="comment">// include statistics.h after marray.h to get these functions</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00205.html">ltl/statistics.h</a>&gt;</span></div>
</div><!-- fragment --><p>Boolean valued reductions:<br/>
<a class="el" href="a00230.html">allof( Expr )</a>, <a class="el" href="a00231.html">noneof( Expr )</a>, and <a class="el" href="a00232.html">anyof( Expr )</a>; additionally there is <a class="el" href="a00233.html">count( Expr )</a>.</p>
<p>All functions below provide an additional instance which neglects an arbitrary <code>NaN</code> value for the calculation of the reduction.</p>
<p>Type <code>T</code> valued reductions:<br/>
<a class="el" href="a00235.html">min( Expr [, T nan] )</a>, <a class="el" href="a00236.html">max( Expr [, T nan] )</a>, <a class="el" href="a00237.html">sum( Expr [, T nan] )</a>, and <a class="el" href="a00238.html">product( Expr [, T nan] )</a>. Minimum, maximum, sum, and product of all values of an expression.</p>
<p>Floating point-valued reductions:<br/>
</p>
<ul>
<li><a class="el" href="a00240.html">average( Expr [, T nan] )</a>, </li>
<li><a class="el" href="a00241.html">variance( Expr [, T nan] [, double mean] )</a>, </li>
<li><a class="el" href="a00242.html">stddev( Expr [, T nan] [, double mean] )</a>, </li>
<li><a class="el" href="a00243.html">median_exact( Expr [, T nan] )</a>, and </li>
<li><a class="el" href="a00244.html">median_estimate( Expr, int bins, T min, T max [, T nan] )</a></li>
</ul>
<p>give the average, the variance or standard deviation (and optionally the average in addition), an exact median and a user scalable estimate of the median.</p>
<p>MArray-valued reduction:<br/>
<a class="el" href="a00245.html">histogram ( Expr, int bins, T min, T max [, T nan] )</a> to build a user defined histogram of an expression.</p>
<p>Kappa-Sigma Clipping:<br/>
</p>
<ul>
<li><a class="el" href="a00248.html">kappa_sigma_average( Expr, double kappa, [T nan,] double mean [, double sigma] )</a>, </li>
<li><a class="el" href="a00249.html">kappa_sigma_median( Expr, double kappa, [T nan,] double mean [, double sigma] )</a>, </li>
<li><a class="el" href="a00250.html">kappa_median_average( Expr, double kappa, [T nan,] double mean [, double sigma] )</a>, and </li>
<li><a class="el" href="a00251.html">kappa_average_median( Expr, double kappa, [T nan,] double mean [, double sigma] )</a>.</li>
</ul>
<p>All these functions do <img class="formulaInl" alt="$\kappa\sigma$" src="form_0.png"/> clipping and return the number of remaining elements after clipping. The resulting mean (average or median) and optionally the final <img class="formulaInl" alt="$\sigma$" src="form_1.png"/> are stored to pointed addresses. For both (median and average results) clipping can be done either according to median and average.</p>
<p>Additionally, we have Tukey's biweight based robust mean and dispersion: </p>
<ul>
<li>robust_sigma </li>
<li>biweight_mean</li>
</ul>
<h2><a class="anchor" id="partial_reductions"></a>
Partial Reductions</h2>
<p><a name="%50artial%20%52eductions"></a></p>
<p>These are reductions like the ones in <a class="el" href="a00003.html#scalar_operations">Full Reductions</a>, except that they operate on one dimension only, resulting in a reduction of the rank of their argument by one.</p>
<p>Partial reductions can be used like any other term in expressions, except they cannot be nested, i.e. it is not possible to partially reduce an expression containing another partial reduction without assigning the result of the first reduction to an MArray first.</p>
<p>For example, to assign the sums of the lines of <code>A</code> (2-dimensional) to the corresponding elements of <code>B</code> (1-dimensional length equal to the number of lines in <code>A</code>) do the following:</p>
<div class="fragment"><div class="line"><span class="comment">// include statistics.h after marray.h to get these functions</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00205.html">ltl/statistics.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">   ...</div>
<div class="line"></div>
<div class="line">   MArray&lt;T,2&gt; A(5,4);</div>
<div class="line">   A = indexPos(A,1) + 10*indexPos(A,2);</div>
<div class="line"></div>
<div class="line">   [[ 11 12 13 14 15 ]</div>
<div class="line">    [ 21 22 23 24 25 ]</div>
<div class="line">    [ 31 32 33 34 35 ]</div>
<div class="line">    [ 41 42 43 44 45 ]]</div>
<div class="line"></div>
<div class="line">   MArray&lt;T,1&gt; B(4);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// partial sum along dimension 1</span></div>
<div class="line">   B = partial_sum( A, 1 );</div>
<div class="line">   <span class="comment">// B = 65, 115, 165, 215;</span></div>
</div><!-- fragment --><p>The following partial reductions are currently implemented for <code>MArray</code> and expression arguments:</p>
<ul>
<li><code><a class="el" href="a00230.html#ga4fa3f06fd8c40e0fe2e53949d1e8ce2b">allof()</a></code> </li>
<li><code><a class="el" href="a00231.html#ga93d860dfba286ce06efff1105b18d1be">noneof()</a></code> </li>
<li><code><a class="el" href="a00232.html#gad35d493309e5b9c960883e3df6986c79">anyof()</a></code> </li>
<li><code><a class="el" href="a00233.html#ga6f039cb2166c16a98ec96bdf34552cb6">count()</a></code> </li>
<li><code><a class="el" href="a00235.html#ga565a8103ce0a613937e0b211f61cddcb">min()</a></code> </li>
<li><code><a class="el" href="a00236.html#gabf6b26e3a08f8a7145b2ea6debe5822b">max()</a></code> </li>
<li><code><a class="el" href="a00237.html#gab581adc068d0fe50a12f817eeae5cb78">sum()</a></code> </li>
<li><code><a class="el" href="a00238.html#ga1a561c8c4b89a9a1782d2c14f601a834">product()</a></code> </li>
<li><code><a class="el" href="a00240.html#ga75e7b33ef3bc491bf244accc57adc439">average()</a></code> </li>
<li><code><a class="el" href="a00241.html#gae295f836b813e3de6c1975f9d7db4980">variance()</a></code> </li>
</ul>
<p>See the discussion of the full reductions with the same name for details.</p>
<h2><a class="anchor" id="typecast"></a>
Typecast Operations for Arrays and Expressions</h2>
<p><a name="type-cast%20cast"></a></p>
<p>If you assign an expression of a different type to a <code>MArray</code>, or mix operands of different types in an expression, the compiler will probably generate a (long and obscure) list of warnings concerning a possible loss of precision, or assignment of incompatible types.</p>
<p>To avoid that, we provide a <code>cast&lt;type&gt;</code> opearation similar to the <code>static_cast&lt;type&gt;</code> operation in <code>C++</code> to convert the type of a <code>MArray</code> or Expression in an assignment, or to convert a sub-expression to a different type.</p>
<p>Usage and semantics are (almost) identical to the <code>static_cast&lt;T&gt;()</code> operation. For example, to cast the elements of an <code>MArray&lt;float,2&gt;</code> <code>A</code> to <code>ints</code>, use:</p>
<div class="fragment"><div class="line">cast&lt;int&gt;()( A )</div>
</div><!-- fragment --><p>See the extra parenthesis to instantiate the <code>cast</code> instance?</p>
<p>To cast a subexpression, use:</p>
<div class="fragment"><div class="line">MArray&lt;int,1&gt; A, B;</div>
<div class="line">MArray&lt;float,1&gt; C, D;</div>
<div class="line">...</div>
<div class="line">B = A + cast&lt;int&gt;()( C/(2.0*D) );</div>
</div><!-- fragment --><h2><a class="anchor" id="convolutions"></a>
Convolution support in MArray expressions</h2>
<p><a name="convolution%20kernels"></a> <a name="derivatives"></a> <a name="gradient%20operator"></a></p>
<p>MArray expression support convolution operations with small kernels. To use this feature, include </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00173.html">ltl/convolve.h</a>&gt;</span>.</div>
</div><!-- fragment --><p>Convolution kernels for <code>MArrays</code> are available implementing various smoothing kernels and finite differences methods that can be used in any <code>MArray</code> expression. Currently, convolutions are implemented for expressions of up to rank 3.</p>
<p>As an example of a declaration of a convolution kernel, let us consider the o(h^2) first derivative along the dimension dim using central differences:</p>
<div class="fragment"><div class="line"><a class="code" href="a00173.html#ac5b7fc69b074eb9af2bec63631da5e5d">DECLARE_CONVOLUTION_OPERATOR_DIM</a>(cderiv1,A)</div>
<div class="line">    return <a class="code" href="a00173.html#a1478930ad2ef06953871b5b5f1ffe16d">OFFSET1</a>(A,1,dim) - <a class="code" href="a00173.html#a1478930ad2ef06953871b5b5f1ffe16d">OFFSET1</a>(A,-1,dim);</div>
<div class="line">END_CONVOLUTION_OPERATOR;</div>
</div><!-- fragment --><p>The macros <code><a class="el" href="a00173.html#ad47dbc31ae9480b9cc7bcb61c109becb">OFFSET0()</a></code>, <code><a class="el" href="a00173.html#a701d9896bc49b59b3287568857bd01ff">OFFSET(i,dim)</a></code>, <code><a class="el" href="a00173.html#a1478930ad2ef06953871b5b5f1ffe16d">OFFSET1(i)</a></code>, <code><a class="el" href="a00173.html#a9c955a0945b3e6407f48a1d9c33d81eb">OFFSET2(i,j)</a></code>, <code><a class="el" href="a00173.html#a265e3e42d038f4484d2cad335ab26fca">OFFSET3(i,j,k)</a></code> allow access to elements of an expression relative to the current position. The offsets can be along any one particular dimension, or along dimensions one, two, and/or three (currently, convolutions are only supported in expression up to rank 3). <code><a class="el" href="a00173.html#ad47dbc31ae9480b9cc7bcb61c109becb">OFFSET0()</a></code> is short for the current element (element at offset 0). The extent of the convolution kernel (the maximum offsets used in the kernel) are determined automatically for you before the operation is executed. The extent can be different in each dimension and in each direction within a dimension. The convolution will only be evaluated for elements of the operand expression for which the kernel lies completely within the domain of the expression. <b>The elements at the boundary will not be accessed.</b></p>
<p>This kernel can then be used in expressions:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; B, C;</div>
<div class="line">...</div>
<div class="line">B = 1/(2*h) * convolve( C*C/2, cderiv1(dim) );</div>
</div><!-- fragment --><p>Which would assign the first derivative along the first dimension of <code>C*C/2</code> to <code>B</code>.</p>
<p>Note that convolutions can provide higher-order tensors than their operands. An example is the gradient operator: </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A(10,10);</div>
<div class="line">MArray&lt;FVector&lt;float,2&gt;,2&gt; B(10,10);</div>
<div class="line">A = 0.0f;</div>
<div class="line">A(5,5) = 1.0f;</div>
<div class="line">B = convolve(A,grad2D());</div>
</div><!-- fragment --><p>See the documentation on kernels for more details and for a list of kernels.</p>
<h2><a class="anchor" id="blas"></a>
BLAS and LAPACK interface</h2>
<p><a name="%42%4cA%53"></a> <a name="%4cA%50A%43%4b"></a> <a name="%4cinear%20algebra"></a></p>
<p>While the LTL comes with its own implementation of the scalar product <code>dot()</code>, most people will want to use BLAS and LAPACK for more complex linear algebra, especially where optimal performance is important.</p>
<p>LTL provides an interface to use BLAS and LAPACK calls on MArrays of dimension one and two. This interface can be used by</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00169.html">ltl/marray/blas.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00187.html">ltl/marray/lapack.h</a>&gt;</span></div>
</div><!-- fragment --><p>These headers can be used independently. <code><a class="el" href="a00169.html">blas.h</a></code> provides BLAS Level 1, 2, and 3 calls on vectors and matrices of float, double, std::complex&lt;float&gt;, and std::complex&lt;double&gt;. <code><a class="el" href="a00187.html">lapack.h</a></code> provides a selection of LAPACK calls. It is very easy to extend it to new calls. See the following snippet for an example and the documentation in these files for details.</p>
<div class="fragment"><div class="line">MArray&lt;float,1&gt; x(4);</div>
<div class="line">...</div>
<div class="line">MArray&lt;float,2&gt; A(3,4);</div>
<div class="line">A = 1,5,9,</div>
<div class="line">    2,6,10,</div>
<div class="line">    3,7,11,</div>
<div class="line">    4,8,12;  <span class="comment">// note: column major order ...</span></div>
<div class="line"></div>
<div class="line">MArray&lt;float,1&gt; y = <a class="code" href="a00169.html#af0910f9a146aa0910555baca6456c56f">blas_gemv</a>( A, x );</div>
</div><!-- fragment --><h2><a class="anchor" id="fftw"></a>
fftw3 interface</h2>
<p>LTL provides an interface to the fftw3 fast fourier transfrom library and provides calls for real and complex transforms of <code>MArrays</code> up to rank 3. See the documentation for <code><a class="el" href="a00177.html">fftw.h</a></code> and the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00177.html">ltl/fftw.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// example of 1-dimensional FFT using fftw3 library:</span></div>
<div class="line">MArray&lt;double, 1&gt; in(size);</div>
<div class="line">MArray&lt;std::complex&lt;double&gt;, 1&gt; out(size);</div>
<div class="line">FourierTransform&lt;double,1&gt; FFT;</div>
<div class="line"></div>
<div class="line">in = 10.0 +</div>
<div class="line">     20.0 * sin(<a class="code" href="a00253.html#ga966fb96d100d1773af124303094eda2d">indexPosDbl</a>(in,1) / <span class="keywordtype">double</span>(size) * 2.0 * M_PI * 3.0) +</div>
<div class="line">     30.0 * cos(<a class="code" href="a00253.html#ga966fb96d100d1773af124303094eda2d">indexPosDbl</a>(in,1) / <span class="keywordtype">double</span>(size) * 2.0 * M_PI * 4.0);</div>
<div class="line">FFT.FFT_Real2Complex(in,out);</div>
<div class="line">FFT.normalize(out);</div>
<div class="line">out = merge(real(out * conj(out)) &gt; 1e-9, out, 0);</div>
<div class="line">std::cout &lt;&lt; out &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="plotting"></a>
Plotting</h2>
<p><a name="plotting%20%47nuplot"></a></p>
<p>Since version 2.0, LTL provides a simple interface to Gnuplot for <code>MArrays</code> and <code>FVectors</code>.</p>
<p>Usage is very simple: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00185.html">ltl/util/gnuplot.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">MArray&lt;float,1&gt; A;</div>
<div class="line"></div>
<div class="line">Gnuplot gp;  <span class="comment">// start a gnuplot session and open pipe</span></div>
<div class="line">Gnuplot gp (<span class="stringliteral">&quot;gnuplot-cmd&quot;</span>); <span class="comment">// alternative command string</span></div>
<div class="line"></div>
<div class="line">gp &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; with lines\n&quot;</span>;</div>
<div class="line">gp.send (A);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="comment">// gp.send(X,Y)</span></div>
<div class="line"><span class="comment">// gp.send_iter( v.begin(), v.end() );</span></div>
<div class="line"><span class="comment">// gp.send_iter( float*, float* );</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> mx, my;</div>
<div class="line"><span class="keywordtype">int</span> mb;</div>
<div class="line">gp.getMouse(mx, my, mb);</div>
</div><!-- fragment --><p><code>Gnuplot::send()</code> works with <code>MArrays</code> up to dimension 2, <code>FVectors</code>. For stdlib containers use <code>send</code> with any valid iterator range, i.e. <code>send</code>(v.begin(),v.end())</p>
<p><code>Gnuplot</code> inherits from <code>std::ostream</code>, so any gnuplot commands and data can be sent to <code>Gnuplot</code> via standard streamio operations, <code>operator&lt;&lt;</code>, <code>setprecision()</code>, etc.</p>
<h2><a class="anchor" id="vectorization"></a>
Vectorization using MMX/SSE/SSE2 and Altivec</h2>
<p><a name="auto-vectorization"></a> <a name="vectorization"></a></p>
<p>As of LTL version 1.7, LTL is capable of automatically generating code for the vector execution units in modern processors. This is essentially an auto-vectorizer for compilers that do not have this feature (e.g. GCC; also, auto-vectorizing compilers do not generate very useful results most of the time).</p>
<p>If all operations in an expression have vector implementations, LTL can automatically vectorize the execution of the loop over the expression for you. This is controlled via the <code>LTL_USE_SIMD</code> preprocessor macro. If <code>LTL_USE_SIMD</code> is defined (before any LTL includes), LTL will evaluate expressions using the hardware vector unit in the current translation unit. Define the macro <code>LTL_DEBUG_EXPRESSIONS</code> to see which loops in your code actually got vectorized.</p>
<p>Vectorization additionally requires the data to be aligned to vector boundaries in memory. LTL can cope with misaligned arrays, but given the elementwise nature of vector operations, only if all the operands have the same (mis-)alignment can a loop be vectorized. In such a case, the loop will be vectorized with the first elements up to the next vector alignment boundary evaluated in the scalar units. The same applies for arrays with element number which are not divisible by the vector length.</p>
<p>Currently, the vector units in x86 processors (MMX/SSE/SSE2 instructions) are supported, as well as the Altivec unit in PowerPC processors. On PPC platforms, additionally to defining <code>LTL_USE_SIMD</code>, we expect <code><b>ALTIVEC</b></code> to be defined. GCC (and IBM xlC on Mac OS X) do so automatically if the <code>-faltivec</code> switch to enable altivec support is provided. On x86, we expect at least SSE2 support to be enabled, and <code><b>SSE2</b></code> to be defined, which is accomplished with the <code>-msse2</code> and/or -msse3 switches with GCC (version 3.4 and above).</p>
<p>Not all operations applicable to <code>MArrays</code> above have vectorized implementations yet, though. (see the file <code>ltl/misc/applicops_altivec.h</code>, <code>ltl/misc/applicops_sse.h</code>, and <code>ltl/marray/reductions_sse.h</code>). Currently, many basic mathematical operations and logical operations are vectgorized, along with many of the statistical reductions. We hope to add more operations over time. Aditionally, under Mac OS X, all operations supported by the vMathLib library are vectorized (this includes most of the starndard math library). Also,</p>
<p>We urge everyone to try out this new feature. But make sure you compare results to the scalar version of your code.</p>
<h3><a class="anchor" id="vectorization_caveats"></a>
A few caveats to be aware of</h3>
<p>While regular C/C++ type promotion applies to array expressions and while many reductions apply their own type promotion (e.g. averages are computed in double no matter what type the data is supplied in), this is NOT the case for vectorized expressions. If you request vectorization in a translation unit YOU have to make sure that (a) all expressions involve only arrays of the same type (to guarantee the same vector length and vector operations) and (b) that it is safe to not promote any types, instead calculate everything in the <code>MArray's</code> element type. Additionally, logical expressions (comparisons) yield different repreresentations of <code>true</code> and <code>false</code> if executed in the vector unit (at least in SSE) compared to a scalar operation. E.g., since the vector unit has only bitwise logical operations, <code>true</code> corresponds to <code>0xFFFF</code>, or -1, not +1 as in the scalar unit. Since parts of a vectorize expression (the misaligned and the remainder of the iteration count divided by the vector length) will be evaluated in the scalar unit, expect that the result of a logical operation might contain mixed representations of <code>true</code>. <code>False</code>, however is always represented by 0.</p>
<p>If any of these do not apply to your problem DO NOT REQUEST VECTORIZATION.</p>
<h3><a class="anchor" id="vectorization_summary"></a>
Vectorization summary</h3>
<ul>
<li>Turn vectorziation on by defining <code>LTL_USE_SIMD</code>. </li>
<li>Vectorization can only be used per translation unit, not per expression. </li>
<li>On x86, supply <code>-msse2</code> and/or <code>-msse3</code> compiler switch to GCC. </li>
<li>On PPC, supply <code>-faltivec</code>. On Mac OS X, add <code>-framework</code> <code>Accelerate</code>. </li>
<li>No type promotion is performed. Expressions may only contain operands of the same bit-size (same number of elements per vector). This is not enforced, so your code might silently fail. Do not rely on specific integer representation of <code>true</code>.</li>
</ul>
<p>See the files <code>ltl/misc/applicops-altivec.h</code> and <code>ltl/misc/applicops-sse.h</code> to see which operations are vectorized. Additionally, many reductions have vectorized implementations in <code>ltl/marray/reductions_sse.h</code> .</p>
<h2><a class="anchor" id="user_operations"></a>
User Defined Operations</h2>
<p><a name="%55ser%20%44efined%20%4fperations"></a></p>
<p>Defining one's own functions to be usable in array expressions is pretty easy. There are macros for unary and binary functions which make the matter just a single line of code. Say you have written a function <code>double my_func( double x )</code> and want this function to be applicable in array expressions:</p>
<div class="fragment"><div class="line"><span class="comment">// here&#39;s my function:</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> my_func( <span class="keywordtype">double</span> x )</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">return</span> x/(1+x*x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// now declare the necessary expression templates:</span></div>
<div class="line"><span class="comment">// the arguments are &#39;function name&#39; and &#39;return type&#39;</span></div>
<div class="line">DECLARE_UNARY_FUNCTION( my_func, <span class="keywordtype">double</span> );</div>
</div><!-- fragment --><p>If you have a vectorized version of your function you might add the following to the scalar definition above:</p>
<div class="fragment"><div class="line"><span class="comment">// here&#39;s the vector implementation of my function:</span></div>
<div class="line"><span class="keyword">inline</span> VEC_TYPE(<span class="keywordtype">double</span>) my_func_vec( VEC_TYPE(<span class="keywordtype">double</span>) x )</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line">DECLARE_UNARY_FUNCTION_VEC(my_func, <span class="keywordtype">double</span>, my_func_vec);</div>
</div><!-- fragment --><p>That's it. Now we can write things like:</p>
<div class="fragment"><div class="line">MArray&lt;double,2&gt; A(nx,ny), B(nx,ny);</div>
<div class="line">...</div>
<div class="line">B = my_func(2*A+1) * ( ... );</div>
</div><!-- fragment --><p>Declaring binary functions is as easy. Use the macro</p>
<div class="fragment"><div class="line">DECLARE_BINARY_FUNCTION( my_binary_func, return_type );</div>
<div class="line">DECLARE_BINARY_FUNCTION_VEC( my_binary_func, return_type, my_func_vec_impl );</div>
</div><!-- fragment --><p>in that case. The vectorized implementation can have any name. It will be associated with the scalar function given as the first argument of these macros.</p>
<p>If you have a functor that defines <code>operator()</code>, you may use it in <code>MArray</code> expressions using <code>apply()</code>. A typical definition of such a functor might look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">typedef</span> <span class="keywordtype">float</span> value_type;</div>
<div class="line">   <span class="keyword">enum</span> { isVectorizable = 1 };</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">float</span> operator()( <span class="keywordtype">float</span> a )</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">return</span> a*a;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// SSE implementation of float multiply:</span></div>
<div class="line">   VEC_TYPE(<span class="keywordtype">float</span>) operator()( VEC_TYPE(<span class="keywordtype">float</span>) a )</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">return</span> _mm_mul_ps(a,a);</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Just set <code>isVectorizable</code> to 0 and leave out the vector implementation if you do not have a vectorzied version of your operation.</p>
<p>To simplifiy writing vectorized code, we provide the following type traits classes and macros:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>vec_trait</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">   <span class="keyword">typedef</span> T          value_type;          <span class="comment">// The type of the vector&#39;s elements</span></div>
<div class="line">   <span class="keyword">typedef</span> Tint_type  int_value_type;      <span class="comment">// The integer type with the same number of elems per vector</span></div>
<div class="line">   <span class="keyword">typedef</span> TTT        vec_type;            <span class="comment">// The type denoting the vector itself</span></div>
<div class="line">   <span class="keyword">typedef</span> __m128i    arg_type;            <span class="comment">// The type of the arguments to the SSE intrinsics</span></div>
<div class="line">   <span class="keyword">static</span> <span class="keyword">inline</span> vec_type init(<span class="keyword">const</span> T x); <span class="comment">// Method returning a vector with all elems set to x</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> With specializations provided for <code>float</code>, <code>double</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code> <code>long</code>.</p>
<p>And, </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VEC_TYPE(T)          vec_trait&lt;T&gt;::vec_type</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define T_VEC_TYPE(T)        typename VEC_TYPE(T)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define INT_TYPE(T)          vec_trait&lt;T&gt;::int_value_type</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define T_INT_TYPE(T)        typename INT_TYPE(T)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define INT_VEC_TYPE(T)      VEC_TYPE(typename vec_trait&lt;T&gt;::int_value_type)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define T_INT_VEC_TYPE(T)    typename INT_VEC_TYPE(T)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define VARGT(T)             vec_trait&lt;T&gt;::arg_type</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define VARGTLL              VARGT(long long)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define VEC_INIT(T,val)      vec_trait&lt;T&gt;::init(val)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define VEC_ZERO(T)          (vec_trait&lt;T&gt;::vec_type)_mm_setzero_si128()</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define T_VEC_ZERO(T)        (typename vec_trait&lt;T&gt;::vec_type)_mm_setzero_si128()</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define VEC_LEN(T)           ((int)(sizeof(VEC_TYPE(T))/sizeof(T)))</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define T_VEC_LEN(T)         ((int)(sizeof(T_VEC_TYPE(T))/sizeof(T)))</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define VEC_UNION(T)         union{ VEC_TYPE(T) v; T a[VEC_LEN(T)]; }</span></div>
<div class="line"><span class="preprocessor">#define T_VEC_UNION(T)       union{ T_VEC_TYPE(T) v; T a[T_VEC_LEN(T)]; }</span></div>
</div><!-- fragment --><p>All of these are defined in <code>ltl/misc/applicops_sse.h</code>.</p>
<h2><a class="anchor" id="conformability"></a>
Array and Expression Conformability</h2>
<p><a name="Array%20and%20%45xpression%20%43onformability"></a> <a name="%43onformability"></a></p>
<p>Obviously, array-valued operands and expressions need to be of the same 'shape' if they are to be evaluated by elementwise application of the mathematical/arithmetic/logical operations.</p>
<p>Conformability in LTL is defined as</p>
<ul>
<li>being of the same rank, and </li>
<li>having the same number of elements along each dimension.</li>
</ul>
<p>The index ranges <em>do not matter</em> (yes, I'm aware that this is debatable...). This is mainly a decision driven by pragmatism. If you think of, say, 2-dimensional arrays not only as matrices but also of simply collections of data (images, for example), then you want to be able to add one (part of an) image to another image without worrying about index ranges. Sometimes it's convenient to have images centered around index (0,0), e.g. in the sine wave example in <a class="el" href="a00003.html#array_expressions">Array Expressions</a>, and still be able to add such an image to (multiple locations in) another image.</p>
<p>Note that there is a caveat here to be aware of. When using index iterators, the index ranges do matter of course, since index iterators always refer to a specific array/expression and therefore iterate over the index ranges of precisely that array/expression.</p>
<h2><a class="anchor" id="various_methods"></a>
Various Other Methods</h2>
<p><a name="%56arious%20%4fther%20%4dethods"></a></p>
<p>Some methods returning information about or changing the indexing of an <code>MArray</code>. Note that dimensions are counted starting at 1 (what should the zeroth dimension of something be?).</p>
<p>Memory related methods:<br/>
</p>
<ul>
<li>void MArray::free() </li>
<li>void MArray::realloc( const Shape&lt;N&gt;&amp; s ) </li>
<li>void MArray::makeReference( const MArray&amp; other ) </li>
<li>void MArray::makeReferenceWithDims( const MArray&amp; other, const int* dims ) </li>
<li>bool MArray::isAllocated() const </li>
<li>bool MArray::empty() const</li>
</ul>
<p>Geometry related methods:<br/>
</p>
<ul>
<li>void MArray::describeSelf() const </li>
<li>int MArray::nelements() const </li>
<li>int MArray::minIndex( const int dim ) const </li>
<li>int MArray::maxIndex( const int dim ) const </li>
<li>int MArray::length( const int dim ) const </li>
<li>int MArray::stride( const int dim ) const </li>
<li>bool MArray::isConformable( const MArray&lt;T2,N&gt;&amp; other ) const </li>
<li>const Shape&lt;N&gt;* MArray::shape() const, </li>
<li>void MArray::setBase( int B1, ..., int BN ) </li>
<li>MArray&lt;T,N&gt; MArray::reverse() </li>
<li>void MArray::reverseSelf() </li>
<li>MArray&lt;T,N&gt; MArray::transpose() </li>
<li>void MArray::transposeSelf()</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Debugging</h2>
<p><a name="%44ebugging"></a> <a name="%52ange%20checking"></a> <a name="%45xceptions"></a> <a name="%43ore%20dump"></a> <a name="%46orce%20core%20dump"></a> <a name="%4c%54%4c_%52A%4e%47%45_%43%48%45%43%4b%49%4e%47"></a> <a name="%4c%54%4c_A%42%4f%52%54_%4f%4e_%52A%4e%47%45_%45%52%52%4f%52"></a> <a name="%4c%54%4c_%54%48%52%4f%57_%4f%4e_%52A%4e%47%45_%45%52%52%4f%52"></a></p>
<p>Range checking for all expressions involving array indexing or subarray creation can be turned on by defining the preprocessor symbol LTL_RANGE_CHECKING <em>before including any LTL header</em>. The system wide default is defined in the file &lt;ltl/config.h&gt;.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define LTL_RANGE_CHECKING  // turn on range checking</span></div>
<div class="line"><span class="preprocessor">#undef  LTL_RANGE_CHECKING  // turn off range checking [default]</span></div>
</div><!-- fragment --><p>Any range violation will result in either </p>
<ul>
<li>an error message indicating the invalid index and the valid ranges of the indexed array being printed to std::cerr, followed by the abortion of the program and a core dump, or </li>
<li>an exception of type <code>RangeException</code> (derived from the standard-library class <code>std::exception</code>) being thrown. The string obtainable by calling <code>RangeException::what()</code> contains the same information as in the above case.</li>
</ul>
<p>depending on the following preprocessor symbols:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define LTL_ABORT_ON_RANGE_ERROR  // abort and coredump [default]</span></div>
<div class="line"><span class="preprocessor">#define LTL_THROW_ON_RANGE_ERROR  // throw RangeException</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 11 2015 14:54:49 for LTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
