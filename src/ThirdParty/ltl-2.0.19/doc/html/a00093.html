<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LTL: ltl::MArrayIterConst&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="ltl_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LTL
   &#160;<span id="projectnumber">2.0.x</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00214.html">ltl</a></li><li class="navelem"><a class="el" href="a00093.html">MArrayIterConst</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00306.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ltl::MArrayIterConst&lt; T, N &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00252.html">MArray iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits <a class="el" href="a00088.html">ltl::LTLIterator</a>.</p>

<p>Inherited by <a class="el" href="a00092.html">ltl::MArrayIter&lt; T, N &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga8965da5b0e4e4ba8deb8c0f5c533c25a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00252.html#gga8965da5b0e4e4ba8deb8c0f5c533c25aa6ca2ecfe7898312707532ef107df3fc0">dims</a> =N
 }</td></tr>
<tr class="memdesc:ga8965da5b0e4e4ba8deb8c0f5c533c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">These define constants that are used by the expression template engine.  <a href="a00252.html#ga8965da5b0e4e4ba8deb8c0f5c533c25a">More...</a><br/></td></tr>
<tr class="separator:ga8965da5b0e4e4ba8deb8c0f5c533c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad481a73acfaf4ca2bfcd025121f725"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00252.html#ggafad481a73acfaf4ca2bfcd025121f725aa1eccdff80e5f15a63de4d52961b6033">numIndexIter</a> = 0
 }</td></tr>
<tr class="separator:gafad481a73acfaf4ca2bfcd025121f725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a9ab1c5422b3eee79aac66cc16a473"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00252.html#ggad1a9ab1c5422b3eee79aac66cc16a473a08715a9b4eb6a79285ffaf283d31d019">numConvolution</a> = 0
 }</td></tr>
<tr class="separator:gad1a9ab1c5422b3eee79aac66cc16a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2093adecd442e9ad9ed5166f7fe9e4a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00252.html#ggac2093adecd442e9ad9ed5166f7fe9e4aa1e123f229b0a9c98b770678b13bc387e">isVectorizable</a> = 1
 }</td></tr>
<tr class="separator:gac2093adecd442e9ad9ed5166f7fe9e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3e482d060e1325e68d0c2af7e85986"><td class="memItemLeft" align="right" valign="top">typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#ga3f3e482d060e1325e68d0c2af7e85986">iterator_category</a></td></tr>
<tr class="memdesc:ga3f3e482d060e1325e68d0c2af7e85986"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::iterator</code> typedefs  <a href="a00252.html#ga3f3e482d060e1325e68d0c2af7e85986">More...</a><br/></td></tr>
<tr class="separator:ga3f3e482d060e1325e68d0c2af7e85986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa901cb76413b0f086fedadb237a6db80"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#gaa901cb76413b0f086fedadb237a6db80">difference_type</a></td></tr>
<tr class="separator:gaa901cb76413b0f086fedadb237a6db80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fae19e069cb6437b0d3423eeb98de9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt;::<a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a></td></tr>
<tr class="separator:ga24fae19e069cb6437b0d3423eeb98de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4643e4c205cceab89693c23d30b1ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt;<br class="typebreak"/>
::<a class="el" href="a00252.html#gacc4643e4c205cceab89693c23d30b1ef">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#gacc4643e4c205cceab89693c23d30b1ef">const_reference</a></td></tr>
<tr class="separator:gacc4643e4c205cceab89693c23d30b1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7784a9afc65e995b83a92c1027f6e7a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt;<br class="typebreak"/>
::<a class="el" href="a00252.html#gaa7784a9afc65e995b83a92c1027f6e7a">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#gaa7784a9afc65e995b83a92c1027f6e7a">const_pointer</a></td></tr>
<tr class="separator:gaa7784a9afc65e995b83a92c1027f6e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed549e31ea54afedf8f6d2d1871ab28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt;::<a class="el" href="a00252.html#gabed549e31ea54afedf8f6d2d1871ab28">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#gabed549e31ea54afedf8f6d2d1871ab28">reference</a></td></tr>
<tr class="separator:gabed549e31ea54afedf8f6d2d1871ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83146bf8af918c3d664fcc4a643f06b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt;::<a class="el" href="a00252.html#ga83146bf8af918c3d664fcc4a643f06b8">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#ga83146bf8af918c3d664fcc4a643f06b8">pointer</a></td></tr>
<tr class="separator:ga83146bf8af918c3d664fcc4a643f06b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adebf63c8822cf5f205e63bc81761a3eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#adebf63c8822cf5f205e63bc81761a3eb">MArrayIterConst</a> (const <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memdesc:adebf63c8822cf5f205e63bc81761a3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code>iterator</code> for a given <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a>. This will rarely be called by a user.  <a href="#adebf63c8822cf5f205e63bc81761a3eb">More...</a><br/></td></tr>
<tr class="separator:adebf63c8822cf5f205e63bc81761a3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02a65156f8653bd117e70c99456c236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ae02a65156f8653bd117e70c99456c236">MArrayIterConst</a> (const <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt; &amp;array, const _iter_end_tag &amp;E)</td></tr>
<tr class="memdesc:ae02a65156f8653bd117e70c99456c236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code>end-iterator</code> for a given <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a>. This will rarely be called by a user.  <a href="#ae02a65156f8653bd117e70c99456c236">More...</a><br/></td></tr>
<tr class="separator:ae02a65156f8653bd117e70c99456c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876f9431c6c543579e8a20999071a02c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a876f9431c6c543579e8a20999071a02c">MArrayIterConst</a> (const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;other)</td></tr>
<tr class="memdesc:a876f9431c6c543579e8a20999071a02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a876f9431c6c543579e8a20999071a02c">More...</a><br/></td></tr>
<tr class="separator:a876f9431c6c543579e8a20999071a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405dd3475868f5c4efe056330d300f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a405dd3475868f5c4efe056330d300f3b">reset</a> ()</td></tr>
<tr class="memdesc:a405dd3475868f5c4efe056330d300f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the iterator back to the first element.  <a href="#a405dd3475868f5c4efe056330d300f3b">More...</a><br/></td></tr>
<tr class="separator:a405dd3475868f5c4efe056330d300f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b63727ec0090e17b85df53a8f27695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ae0b63727ec0090e17b85df53a8f27695">operator*</a> () const </td></tr>
<tr class="memdesc:ae0b63727ec0090e17b85df53a8f27695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the iterator object. Return the element pointed to.  <a href="#ae0b63727ec0090e17b85df53a8f27695">More...</a><br/></td></tr>
<tr class="separator:ae0b63727ec0090e17b85df53a8f27695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964c28ee42a50daa65a985e1bf9ddf29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">operator++</a> ()</td></tr>
<tr class="memdesc:a964c28ee42a50daa65a985e1bf9ddf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the iterator to the next object.  <a href="#a964c28ee42a50daa65a985e1bf9ddf29">More...</a><br/></td></tr>
<tr class="separator:a964c28ee42a50daa65a985e1bf9ddf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae455136ed33685a77489f39089a6ffcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ae455136ed33685a77489f39089a6ffcb">operator++</a> (<a class="el" href="a00262.html">int</a>)</td></tr>
<tr class="memdesc:ae455136ed33685a77489f39089a6ffcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix <code><a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29" title="Move the iterator to the next object. ">operator++()</a></code>.  <a href="#ae455136ed33685a77489f39089a6ffcb">More...</a><br/></td></tr>
<tr class="separator:ae455136ed33685a77489f39089a6ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca5fd9734bd5fdcf26552815f826013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a8ca5fd9734bd5fdcf26552815f826013">operator==</a> (const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a8ca5fd9734bd5fdcf26552815f826013"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if iterators share the same data pointer  <a href="#a8ca5fd9734bd5fdcf26552815f826013">More...</a><br/></td></tr>
<tr class="separator:a8ca5fd9734bd5fdcf26552815f826013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96135bafc09698eb35869021459206ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a96135bafc09698eb35869021459206ab">operator!=</a> (const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a96135bafc09698eb35869021459206ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if iterators do not share the same data pointer  <a href="#a96135bafc09698eb35869021459206ab">More...</a><br/></td></tr>
<tr class="separator:a96135bafc09698eb35869021459206ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4e4eb6693257a16e1c1d09f2348a8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#acb4e4eb6693257a16e1c1d09f2348a8a">done</a> () const </td></tr>
<tr class="memdesc:acb4e4eb6693257a16e1c1d09f2348a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we point past the end, i.e. we are equal to the end iterator.  <a href="#acb4e4eb6693257a16e1c1d09f2348a8a">More...</a><br/></td></tr>
<tr class="separator:acb4e4eb6693257a16e1c1d09f2348a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a4dd28287607ba13097c633f9dc70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a8e0a4dd28287607ba13097c633f9dc70">isConformable</a> (const <a class="el" href="a00119.html">Shape</a>&lt; N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a8e0a4dd28287607ba13097c633f9dc70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if we have the same array geometry as that of <code>other</code>,  <a href="#a8e0a4dd28287607ba13097c633f9dc70">More...</a><br/></td></tr>
<tr class="separator:a8e0a4dd28287607ba13097c633f9dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65525e38a5c1f32f54f0224ee187a33c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a65525e38a5c1f32f54f0224ee187a33c">printRanges</a> () const </td></tr>
<tr class="memdesc:a65525e38a5c1f32f54f0224ee187a33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print the geometry.  <a href="#a65525e38a5c1f32f54f0224ee187a33c">More...</a><br/></td></tr>
<tr class="separator:a65525e38a5c1f32f54f0224ee187a33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6378a7f27402ff40a078e24f570fd19c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00119.html">Shape</a>&lt; N &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a6378a7f27402ff40a078e24f570fd19c">shape</a> () const </td></tr>
<tr class="memdesc:a6378a7f27402ff40a078e24f570fd19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return our <code>shape</code>.  <a href="#a6378a7f27402ff40a078e24f570fd19c">More...</a><br/></td></tr>
<tr class="separator:a6378a7f27402ff40a078e24f570fd19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ed76f21506aaeca7d98a708fd359e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a37ed76f21506aaeca7d98a708fd359e7">isStorageContiguous</a> () const </td></tr>
<tr class="memdesc:a37ed76f21506aaeca7d98a708fd359e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if the memory we are pointing to has contiguous memory layout.  <a href="#a37ed76f21506aaeca7d98a708fd359e7">More...</a><br/></td></tr>
<tr class="separator:a37ed76f21506aaeca7d98a708fd359e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531f5d48cdb2ae0f73d6568d11d574e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a531f5d48cdb2ae0f73d6568d11d574e5">isStride1</a> () const </td></tr>
<tr class="memdesc:a531f5d48cdb2ae0f73d6568d11d574e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if our innermost stride is 1  <a href="#a531f5d48cdb2ae0f73d6568d11d574e5">More...</a><br/></td></tr>
<tr class="separator:a531f5d48cdb2ae0f73d6568d11d574e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb0b7c81db52d6f091e5f3a4a4e9a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a8fb0b7c81db52d6f091e5f3a4a4e9a25">data</a> () const </td></tr>
<tr class="memdesc:a8fb0b7c81db52d6f091e5f3a4a4e9a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current data pointer.  <a href="#a8fb0b7c81db52d6f091e5f3a4a4e9a25">More...</a><br/></td></tr>
<tr class="separator:a8fb0b7c81db52d6f091e5f3a4a4e9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c4cfd43e62d4aa79e3d07b178b21078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a8c4cfd43e62d4aa79e3d07b178b21078">advance</a> ()</td></tr>
<tr class="memdesc:a8c4cfd43e62d4aa79e3d07b178b21078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide separate versions of <a class="el" href="a00093.html#a8c4cfd43e62d4aa79e3d07b178b21078" title="Provide separate versions of advance() for incrementing the innermost. ">advance()</a> for incrementing the innermost.  <a href="#a8c4cfd43e62d4aa79e3d07b178b21078">More...</a><br/></td></tr>
<tr class="separator:a8c4cfd43e62d4aa79e3d07b178b21078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ceb0f9e83677330a2ed850dd0f7a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ae6ceb0f9e83677330a2ed850dd0f7a11">advance</a> (<a class="el" href="a00262.html">int</a> n)</td></tr>
<tr class="memdesc:ae6ceb0f9e83677330a2ed850dd0f7a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally increase the data pointer by N innermost strides.  <a href="#ae6ceb0f9e83677330a2ed850dd0f7a11">More...</a><br/></td></tr>
<tr class="separator:ae6ceb0f9e83677330a2ed850dd0f7a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1ce3b0a618bda80012a8e7938cf256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a1f1ce3b0a618bda80012a8e7938cf256">advance</a> (<a class="el" href="a00262.html">int</a> n, <a class="el" href="a00262.html">int</a> dim)</td></tr>
<tr class="memdesc:a1f1ce3b0a618bda80012a8e7938cf256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally increase the data pointer by N along dimension dim (used for partial reductions).  <a href="#a1f1ce3b0a618bda80012a8e7938cf256">More...</a><br/></td></tr>
<tr class="separator:a1f1ce3b0a618bda80012a8e7938cf256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea76a85900b75f9dd0b113909da619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#aafea76a85900b75f9dd0b113909da619">advanceWithStride1</a> ()</td></tr>
<tr class="memdesc:aafea76a85900b75f9dd0b113909da619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally increase the data pointer by one.  <a href="#aafea76a85900b75f9dd0b113909da619">More...</a><br/></td></tr>
<tr class="separator:aafea76a85900b75f9dd0b113909da619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffad5d410d93276299b77e8a6dbab92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a0ffad5d410d93276299b77e8a6dbab92">needAdvanceDim</a> () const </td></tr>
<tr class="memdesc:a0ffad5d410d93276299b77e8a6dbab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have reached the end of the innermost dimension.  <a href="#a0ffad5d410d93276299b77e8a6dbab92">More...</a><br/></td></tr>
<tr class="separator:a0ffad5d410d93276299b77e8a6dbab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd172cdd359eb4be36235e4b6beb4a26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#acd172cdd359eb4be36235e4b6beb4a26">advanceDim</a> ()</td></tr>
<tr class="memdesc:acd172cdd359eb4be36235e4b6beb4a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator past the end of one "line" (the end of the innermost dimension).  <a href="#acd172cdd359eb4be36235e4b6beb4a26">More...</a><br/></td></tr>
<tr class="separator:acd172cdd359eb4be36235e4b6beb4a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866ca9716266b5bf6ba8950d4a88590a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a866ca9716266b5bf6ba8950d4a88590a">advanceDim</a> (const <a class="el" href="a00262.html">int</a> cutDim)</td></tr>
<tr class="memdesc:a866ca9716266b5bf6ba8950d4a88590a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator past the end of one "line", ignoring the dimension cutDim (used in partial reductions).  <a href="#a866ca9716266b5bf6ba8950d4a88590a">More...</a><br/></td></tr>
<tr class="separator:a866ca9716266b5bf6ba8950d4a88590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59f07ba555dc821b4e578ac2fae47855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a59f07ba555dc821b4e578ac2fae47855">readWithoutStride</a> (const <a class="el" href="a00262.html">int</a> i) const </td></tr>
<tr class="memdesc:a59f07ba555dc821b4e578ac2fae47855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at the current location + i (optimized for stride 1).  <a href="#a59f07ba555dc821b4e578ac2fae47855">More...</a><br/></td></tr>
<tr class="separator:a59f07ba555dc821b4e578ac2fae47855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83d1f4dc94d9514985a3611f21d8b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ae83d1f4dc94d9514985a3611f21d8b6b">readWithStride</a> (const <a class="el" href="a00262.html">int</a> i) const </td></tr>
<tr class="memdesc:ae83d1f4dc94d9514985a3611f21d8b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current data value at the current location + i*stride.  <a href="#ae83d1f4dc94d9514985a3611f21d8b6b">More...</a><br/></td></tr>
<tr class="separator:ae83d1f4dc94d9514985a3611f21d8b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d17a944128aced46a1fe4cbcb8fbf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a02d17a944128aced46a1fe4cbcb8fbf6">readWithStride</a> (const <a class="el" href="a00262.html">int</a> i, const <a class="el" href="a00262.html">int</a> dim) const </td></tr>
<tr class="memdesc:a02d17a944128aced46a1fe4cbcb8fbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at position i along dimension dim (used in partial reductions)  <a href="#a02d17a944128aced46a1fe4cbcb8fbf6">More...</a><br/></td></tr>
<tr class="separator:a02d17a944128aced46a1fe4cbcb8fbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c8fb538a4266efa1a4aeb52ef93b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a22c8fb538a4266efa1a4aeb52ef93b3a">readAtOffsetDim</a> (const <a class="el" href="a00262.html">int</a> i, const <a class="el" href="a00262.html">int</a> dim) const </td></tr>
<tr class="memdesc:a22c8fb538a4266efa1a4aeb52ef93b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at offset i along dim dim (used in convolutions)  <a href="#a22c8fb538a4266efa1a4aeb52ef93b3a">More...</a><br/></td></tr>
<tr class="separator:a22c8fb538a4266efa1a4aeb52ef93b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05489721a39ab6e322e971835eca764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#aa05489721a39ab6e322e971835eca764">readAtOffset</a> (const <a class="el" href="a00262.html">int</a> i) const </td></tr>
<tr class="memdesc:aa05489721a39ab6e322e971835eca764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at offset i along dim 1 (used in convolutions)  <a href="#aa05489721a39ab6e322e971835eca764">More...</a><br/></td></tr>
<tr class="separator:aa05489721a39ab6e322e971835eca764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db">readAtOffset</a> (const <a class="el" href="a00262.html">int</a> i, const <a class="el" href="a00262.html">int</a> j) const </td></tr>
<tr class="memdesc:ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at offset i along dim 1 and j along dim 2 (used in convolutions)  <a href="#ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db">More...</a><br/></td></tr>
<tr class="separator:ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8716cc1cae0a9643535b776bcd86815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ad8716cc1cae0a9643535b776bcd86815">readAtOffset</a> (const <a class="el" href="a00262.html">int</a> i, const <a class="el" href="a00262.html">int</a> j, const <a class="el" href="a00262.html">int</a> k) const </td></tr>
<tr class="memdesc:ad8716cc1cae0a9643535b776bcd86815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data value at offset i along dim 1, j along dim 2, and k along dim 3 (used in convolutions)  <a href="#ad8716cc1cae0a9643535b776bcd86815">More...</a><br/></td></tr>
<tr class="separator:ad8716cc1cae0a9643535b776bcd86815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab287f74d85ca17ce5d7da9f51bc7b629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ab287f74d85ca17ce5d7da9f51bc7b629">boundary_l</a> (const <a class="el" href="a00262.html">int</a> dim) const </td></tr>
<tr class="memdesc:ab287f74d85ca17ce5d7da9f51bc7b629"><td class="mdescLeft">&#160;</td><td class="mdescRight">leave boundary around the lower edges of the array (for convolutions)  <a href="#ab287f74d85ca17ce5d7da9f51bc7b629">More...</a><br/></td></tr>
<tr class="separator:ab287f74d85ca17ce5d7da9f51bc7b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdabbe3dc7ab051ab99b6a5d3d6d8651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#abdabbe3dc7ab051ab99b6a5d3d6d8651">boundary_u</a> (const <a class="el" href="a00262.html">int</a> dim) const </td></tr>
<tr class="memdesc:abdabbe3dc7ab051ab99b6a5d3d6d8651"><td class="mdescLeft">&#160;</td><td class="mdescRight">leave boundary around the upper edges of the array (for convolutions)  <a href="#abdabbe3dc7ab051ab99b6a5d3d6d8651">More...</a><br/></td></tr>
<tr class="separator:abdabbe3dc7ab051ab99b6a5d3d6d8651"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a697aec35be4e8b5ba4ba0d8c71c5f47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> *restrict_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">data_</a></td></tr>
<tr class="separator:a697aec35be4e8b5ba4ba0d8c71c5f47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7873471ce7fb307f0a32ea3ab16318a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#af7873471ce7fb307f0a32ea3ab16318a">array_</a></td></tr>
<tr class="separator:af7873471ce7fb307f0a32ea3ab16318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41427a7d475bdd3d12f56fd1ec7d555a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a41427a7d475bdd3d12f56fd1ec7d555a">stack_</a> [N]</td></tr>
<tr class="separator:a41427a7d475bdd3d12f56fd1ec7d555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257a597aa9ffe486b3f3aec280ce65db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">last_</a> [N]</td></tr>
<tr class="separator:a257a597aa9ffe486b3f3aec280ce65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68cc41da16379600e06be195b91a086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">strides_</a> [N]</td></tr>
<tr class="separator:aa68cc41da16379600e06be195b91a086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8124935219beb38a96aa65c251bddb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#a8124935219beb38a96aa65c251bddb65">length_</a> [N]</td></tr>
<tr class="separator:a8124935219beb38a96aa65c251bddb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47d85b210645104108af9eaeb71b26b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00262.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">stride_</a></td></tr>
<tr class="separator:ad47d85b210645104108af9eaeb71b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int N&gt;<br/>
class ltl::MArrayIterConst&lt; T, N &gt;</h3>

<p>Const iterator object for ltl::MArrays. Conforms to std::forward_iterator. The non-const version is implemented below by inheriting from this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adebf63c8822cf5f205e63bc81761a3eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::<a class="el" href="a00093.html">MArrayIterConst</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <code>iterator</code> for a given <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a>. This will rarely be called by a user. </p>

</div>
</div>
<a class="anchor" id="ae02a65156f8653bd117e70c99456c236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::<a class="el" href="a00093.html">MArrayIterConst</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00091.html">MArray</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _iter_end_tag &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <code>end-iterator</code> for a given <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a>. This will rarely be called by a user. </p>

<p>References <a class="el" href="a00091.html#aee4365e14586f27f1f6c86659b2c93be">ltl::MArray&lt; T, N &gt;::data()</a>, <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, <a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">ltl::MArrayIterConst&lt; T, N &gt;::last_</a>, <a class="el" href="a00091.html#a14fb18d4dec7fcf37f8cef5f91e2fc5e">ltl::MArray&lt; T, N &gt;::nelements()</a>, and <a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">ltl::MArrayIterConst&lt; T, N &gt;::stride_</a>.</p>

</div>
</div>
<a class="anchor" id="a876f9431c6c543579e8a20999071a02c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::<a class="el" href="a00093.html">MArrayIterConst</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>

<p>References <a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">ltl::MArrayIterConst&lt; T, N &gt;::last_</a>, <a class="el" href="a00093.html#a8124935219beb38a96aa65c251bddb65">ltl::MArrayIterConst&lt; T, N &gt;::length_</a>, <a class="el" href="a00093.html#a41427a7d475bdd3d12f56fd1ec7d555a">ltl::MArrayIterConst&lt; T, N &gt;::stack_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a405dd3475868f5c4efe056330d300f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the iterator back to the first element. </p>

</div>
</div>
<a class="anchor" id="ae0b63727ec0090e17b85df53a8f27695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the iterator object. Return the element pointed to. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#acb4e4eb6693257a16e1c1d09f2348a8a">ltl::MArrayIterConst&lt; T, N &gt;::done()</a>.</p>

</div>
</div>
<a class="anchor" id="a964c28ee42a50daa65a985e1bf9ddf29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">MArrayIterConst</a>&lt;T,N&gt;&amp; <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the iterator to the next object. </p>
<p>This method will almost never be used. Instead, more efficient versions will be used by the expression template engine to move iterators forward.</p>
<p>This implementation of <code><a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29" title="Move the iterator to the next object. ">operator++()</a></code> will check for the end condition every time it is called. When we evaluate an expression, all iterators involved in the expression point to MArrays or expressions of the same geometry, so checking for the end condition on ONE of the iterators is enough. We also know the length of the dimension(s), so we can optimize the increment past the end of one dimension (where we have to reset this dimension and use a different stride to increment the next-outer dimension). See below and implementation of evaluation methods in ltl/marray/eval.h. </p>

<p>References <a class="el" href="a00093.html#a8c4cfd43e62d4aa79e3d07b178b21078">ltl::MArrayIterConst&lt; T, N &gt;::advance()</a>, <a class="el" href="a00093.html#acd172cdd359eb4be36235e4b6beb4a26">ltl::MArrayIterConst&lt; T, N &gt;::advanceDim()</a>, <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, <a class="el" href="a00093.html#acb4e4eb6693257a16e1c1d09f2348a8a">ltl::MArrayIterConst&lt; T, N &gt;::done()</a>, and <a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">ltl::MArrayIterConst&lt; T, N &gt;::last_</a>.</p>

<p>Referenced by <a class="el" href="a00092.html#afa691547ce099a20ba235445d1119545">ltl::MArrayIter&lt; T, N &gt;::operator++()</a>.</p>

</div>
</div>
<a class="anchor" id="ae455136ed33685a77489f39089a6ffcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postfix <code><a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29" title="Move the iterator to the next object. ">operator++()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a8c4cfd43e62d4aa79e3d07b178b21078"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide separate versions of <a class="el" href="a00093.html#a8c4cfd43e62d4aa79e3d07b178b21078" title="Provide separate versions of advance() for incrementing the innermost. ">advance()</a> for incrementing the innermost. </p>
<p>When evaluating an expression involving more than one iterator all terms MUST have the same geometry, the loop structures are identical. It's therefore sufficient to check the end of loop condition and the end of one dimension on one of the iterators ... All others are then 'remote controlled' via these methods methods. See implementation of evaluation methods in ltl/marray/eval.h.Unconditionally increase the data pointer by one innermost stride. </p>

<p>Referenced by <a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">ltl::MArrayIterConst&lt; T, N &gt;::operator++()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6ceb0f9e83677330a2ed850dd0f7a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unconditionally increase the data pointer by N innermost strides. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">ltl::MArrayIterConst&lt; T, N &gt;::stride_</a>.</p>

</div>
</div>
<a class="anchor" id="a1f1ce3b0a618bda80012a8e7938cf256"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unconditionally increase the data pointer by N along dimension dim (used for partial reductions). </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<a class="anchor" id="aafea76a85900b75f9dd0b113909da619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advanceWithStride1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unconditionally increase the data pointer by one. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>.</p>

</div>
</div>
<a class="anchor" id="a0ffad5d410d93276299b77e8a6dbab92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::needAdvanceDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we have reached the end of the innermost dimension. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">ltl::MArrayIterConst&lt; T, N &gt;::last_</a>.</p>

</div>
</div>
<a class="anchor" id="acd172cdd359eb4be36235e4b6beb4a26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advanceDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator past the end of one "line" (the end of the innermost dimension). </p>

<p>Referenced by <a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">ltl::MArrayIterConst&lt; T, N &gt;::operator++()</a>.</p>

</div>
</div>
<a class="anchor" id="a866ca9716266b5bf6ba8950d4a88590a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::advanceDim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>cutDim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator past the end of one "line", ignoring the dimension cutDim (used in partial reductions). </p>

</div>
</div>
<a class="anchor" id="a59f07ba555dc821b4e578ac2fae47855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readWithoutStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at the current location + i (optimized for stride 1). </p>
<p>These methods are for implementing loop unrolling and vectorization for the efficient evaluation of expression templates. </p>

</div>
</div>
<a class="anchor" id="ae83d1f4dc94d9514985a3611f21d8b6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readWithStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current data value at the current location + i*stride. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">ltl::MArrayIterConst&lt; T, N &gt;::stride_</a>.</p>

</div>
</div>
<a class="anchor" id="a02d17a944128aced46a1fe4cbcb8fbf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readWithStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at position i along dimension dim (used in partial reductions) </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<a class="anchor" id="a22c8fb538a4266efa1a4aeb52ef93b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readAtOffsetDim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at offset i along dim dim (used in convolutions) </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<a class="anchor" id="aa05489721a39ab6e322e971835eca764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readAtOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at offset i along dim 1 (used in convolutions) </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">ltl::MArrayIterConst&lt; T, N &gt;::stride_</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readAtOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at offset i along dim 1 and j along dim 2 (used in convolutions) </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<a class="anchor" id="ad8716cc1cae0a9643535b776bcd86815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::readAtOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data value at offset i along dim 1, j along dim 2, and k along dim 3 (used in convolutions) </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#aa68cc41da16379600e06be195b91a086">ltl::MArrayIterConst&lt; T, N &gt;::strides_</a>.</p>

</div>
</div>
<a class="anchor" id="ab287f74d85ca17ce5d7da9f51bc7b629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">int</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::boundary_l </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>leave boundary around the lower edges of the array (for convolutions) </p>

</div>
</div>
<a class="anchor" id="abdabbe3dc7ab051ab99b6a5d3d6d8651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">int</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::boundary_u </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00262.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>leave boundary around the upper edges of the array (for convolutions) </p>

</div>
</div>
<a class="anchor" id="a8ca5fd9734bd5fdcf26552815f826013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if iterators share the same data pointer </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>.</p>

</div>
</div>
<a class="anchor" id="a96135bafc09698eb35869021459206ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html">MArrayIterConst</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if iterators do not share the same data pointer </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>.</p>

</div>
</div>
<a class="anchor" id="acb4e4eb6693257a16e1c1d09f2348a8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if we point past the end, i.e. we are equal to the end iterator. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>, and <a class="el" href="a00093.html#a257a597aa9ffe486b3f3aec280ce65db">ltl::MArrayIterConst&lt; T, N &gt;::last_</a>.</p>

<p>Referenced by <a class="el" href="a00251.html#ga71a58ca3295b309e221dba657deed0fe">ltl::average_clip_median()</a>, <a class="el" href="a00112.html#aef81c89b68d10014c78e3aedbab02c3b">ltl::PolynomFit&lt; TPAR, TDAT, ORDER, EXT, 1 &gt;::eval()</a>, <a class="el" href="a00112.html#a5f3147f3f793f30b71583ce0b614ea27">ltl::PolynomFit&lt; TPAR, TDAT, ORDER, EXT, 1 &gt;::fill()</a>, <a class="el" href="a00250.html#ga4530ff772120ed851d8a6e40794db8fa">ltl::median_clip_average()</a>, <a class="el" href="a00093.html#ae0b63727ec0090e17b85df53a8f27695">ltl::MArrayIterConst&lt; T, N &gt;::operator*()</a>, <a class="el" href="a00092.html#a37b80ab6f91aa456ca917e58d145f8d4">ltl::MArrayIter&lt; T, N &gt;::operator*()</a>, <a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">ltl::MArrayIterConst&lt; T, N &gt;::operator++()</a>, and <a class="el" href="a00219.html#ga99e413e83fbfd31cef75d83aba3e07e2">ltl::MArray&lt; T, N &gt;::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e0a4dd28287607ba13097c633f9dc70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::isConformable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00119.html">Shape</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if we have the same array geometry as that of <code>other</code>, </p>

<p>References <a class="el" href="a00093.html#a6378a7f27402ff40a078e24f570fd19c">ltl::MArrayIterConst&lt; T, N &gt;::shape()</a>.</p>

</div>
</div>
<a class="anchor" id="a65525e38a5c1f32f54f0224ee187a33c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::printRanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print the geometry. </p>

</div>
</div>
<a class="anchor" id="a6378a7f27402ff40a078e24f570fd19c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00119.html">Shape</a>&lt;N&gt;* <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return our <code>shape</code>. </p>

<p>References <a class="el" href="a00093.html#af7873471ce7fb307f0a32ea3ab16318a">ltl::MArrayIterConst&lt; T, N &gt;::array_</a>.</p>

<p>Referenced by <a class="el" href="a00093.html#a8e0a4dd28287607ba13097c633f9dc70">ltl::MArrayIterConst&lt; T, N &gt;::isConformable()</a>, and <a class="el" href="a00093.html#a37ed76f21506aaeca7d98a708fd359e7">ltl::MArrayIterConst&lt; T, N &gt;::isStorageContiguous()</a>.</p>

</div>
</div>
<a class="anchor" id="a37ed76f21506aaeca7d98a708fd359e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::isStorageContiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if the memory we are pointing to has contiguous memory layout. </p>

<p>References <a class="el" href="a00093.html#a6378a7f27402ff40a078e24f570fd19c">ltl::MArrayIterConst&lt; T, N &gt;::shape()</a>.</p>

</div>
</div>
<a class="anchor" id="a531f5d48cdb2ae0f73d6568d11d574e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::isStride1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if our innermost stride is 1 </p>

<p>References <a class="el" href="a00093.html#ad47d85b210645104108af9eaeb71b26b">ltl::MArrayIterConst&lt; T, N &gt;::stride_</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb0b7c81db52d6f091e5f3a4a4e9a25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>* <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current data pointer. </p>

<p>References <a class="el" href="a00093.html#a697aec35be4e8b5ba4ba0d8c71c5f47e">ltl::MArrayIterConst&lt; T, N &gt;::data_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a697aec35be4e8b5ba4ba0d8c71c5f47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>* restrict_ <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::data_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#ae6ceb0f9e83677330a2ed850dd0f7a11">ltl::MArrayIterConst&lt; T, N &gt;::advance()</a>, <a class="el" href="a00093.html#aafea76a85900b75f9dd0b113909da619">ltl::MArrayIterConst&lt; T, N &gt;::advanceWithStride1()</a>, <a class="el" href="a00093.html#a8fb0b7c81db52d6f091e5f3a4a4e9a25">ltl::MArrayIterConst&lt; T, N &gt;::data()</a>, <a class="el" href="a00093.html#acb4e4eb6693257a16e1c1d09f2348a8a">ltl::MArrayIterConst&lt; T, N &gt;::done()</a>, <a class="el" href="a00093.html#ae02a65156f8653bd117e70c99456c236">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>, <a class="el" href="a00093.html#a0ffad5d410d93276299b77e8a6dbab92">ltl::MArrayIterConst&lt; T, N &gt;::needAdvanceDim()</a>, <a class="el" href="a00093.html#a96135bafc09698eb35869021459206ab">ltl::MArrayIterConst&lt; T, N &gt;::operator!=()</a>, <a class="el" href="a00093.html#ae0b63727ec0090e17b85df53a8f27695">ltl::MArrayIterConst&lt; T, N &gt;::operator*()</a>, <a class="el" href="a00092.html#a37b80ab6f91aa456ca917e58d145f8d4">ltl::MArrayIter&lt; T, N &gt;::operator*()</a>, <a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">ltl::MArrayIterConst&lt; T, N &gt;::operator++()</a>, <a class="el" href="a00093.html#a8ca5fd9734bd5fdcf26552815f826013">ltl::MArrayIterConst&lt; T, N &gt;::operator==()</a>, <a class="el" href="a00093.html#aa05489721a39ab6e322e971835eca764">ltl::MArrayIterConst&lt; T, N &gt;::readAtOffset()</a>, <a class="el" href="a00093.html#a22c8fb538a4266efa1a4aeb52ef93b3a">ltl::MArrayIterConst&lt; T, N &gt;::readAtOffsetDim()</a>, and <a class="el" href="a00093.html#ae83d1f4dc94d9514985a3611f21d8b6b">ltl::MArrayIterConst&lt; T, N &gt;::readWithStride()</a>.</p>

</div>
</div>
<a class="anchor" id="af7873471ce7fb307f0a32ea3ab16318a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00091.html">MArray</a>&lt;T,N&gt;* <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::array_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#a6378a7f27402ff40a078e24f570fd19c">ltl::MArrayIterConst&lt; T, N &gt;::shape()</a>.</p>

</div>
</div>
<a class="anchor" id="a41427a7d475bdd3d12f56fd1ec7d555a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a>* <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::stack_[N]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#a876f9431c6c543579e8a20999071a02c">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>.</p>

</div>
</div>
<a class="anchor" id="a257a597aa9ffe486b3f3aec280ce65db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html#ga24fae19e069cb6437b0d3423eeb98de9">value_type</a> * <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::last_[N]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#acb4e4eb6693257a16e1c1d09f2348a8a">ltl::MArrayIterConst&lt; T, N &gt;::done()</a>, <a class="el" href="a00093.html#ae02a65156f8653bd117e70c99456c236">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>, <a class="el" href="a00093.html#a0ffad5d410d93276299b77e8a6dbab92">ltl::MArrayIterConst&lt; T, N &gt;::needAdvanceDim()</a>, and <a class="el" href="a00093.html#a964c28ee42a50daa65a985e1bf9ddf29">ltl::MArrayIterConst&lt; T, N &gt;::operator++()</a>.</p>

</div>
</div>
<a class="anchor" id="aa68cc41da16379600e06be195b91a086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">int</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::strides_[N]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#a1f1ce3b0a618bda80012a8e7938cf256">ltl::MArrayIterConst&lt; T, N &gt;::advance()</a>, <a class="el" href="a00093.html#a876f9431c6c543579e8a20999071a02c">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>, <a class="el" href="a00093.html#ab9e4e1c5dbc4c374e2c4e6ed5c8dd2db">ltl::MArrayIterConst&lt; T, N &gt;::readAtOffset()</a>, <a class="el" href="a00093.html#a22c8fb538a4266efa1a4aeb52ef93b3a">ltl::MArrayIterConst&lt; T, N &gt;::readAtOffsetDim()</a>, and <a class="el" href="a00093.html#a02d17a944128aced46a1fe4cbcb8fbf6">ltl::MArrayIterConst&lt; T, N &gt;::readWithStride()</a>.</p>

</div>
</div>
<a class="anchor" id="a8124935219beb38a96aa65c251bddb65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">int</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::length_[N]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#a876f9431c6c543579e8a20999071a02c">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>.</p>

</div>
</div>
<a class="anchor" id="ad47d85b210645104108af9eaeb71b26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00262.html">int</a> <a class="el" href="a00093.html">ltl::MArrayIterConst</a>&lt; T, N &gt;::stride_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00093.html#ae6ceb0f9e83677330a2ed850dd0f7a11">ltl::MArrayIterConst&lt; T, N &gt;::advance()</a>, <a class="el" href="a00093.html#a531f5d48cdb2ae0f73d6568d11d574e5">ltl::MArrayIterConst&lt; T, N &gt;::isStride1()</a>, <a class="el" href="a00093.html#ae02a65156f8653bd117e70c99456c236">ltl::MArrayIterConst&lt; T, N &gt;::MArrayIterConst()</a>, <a class="el" href="a00093.html#aa05489721a39ab6e322e971835eca764">ltl::MArrayIterConst&lt; T, N &gt;::readAtOffset()</a>, and <a class="el" href="a00093.html#ae83d1f4dc94d9514985a3611f21d8b6b">ltl::MArrayIterConst&lt; T, N &gt;::readWithStride()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 11 2015 14:54:50 for LTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
