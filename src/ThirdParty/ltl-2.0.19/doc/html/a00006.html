<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LTL: MArray I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="ltl_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LTL
   &#160;<span id="projectnumber">2.0.x</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">MArray I/O<div class="ingroups"><a class="el" href="a00003.html">Multidimensional Dynamic Arrays</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">MArray Stream I/O</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">MArray ASCII I/O</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00221"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">MArray FITS file I/O</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and methods for interfacing with <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a>. </p>


<h3><a class="anchor" id="maio_doc"></a>MArray I/O</h3><div class="textblock">LTL currently provides I/O interfaces for <code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code> to streams, columnar ASCII files and FITS files. Access to columnar ASCII files and to FITS files is done using the classes <code><a class="el" href="a00015.html" title="Columns based interface to an ASCII data file. ">ltl::AscFile</a></code>, <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code>, and <code><a class="el" href="a00053.html" title="Writing FITS files. ">ltl::FitsOut</a></code>. Access to streams is realized using <code><a class="el" href="a00214.html#a975d4509dce3c520f38239b5e244a70b">ltl::operator&gt;&gt;</a></code> and <code>ltl::operator&lt;&lt;</code>, in accordance with the standard library.<h1><a class="anchor" id="streamio_doc"></a>
Streams</h1>
<p><a name="%53tream%20%49%2f%4f"></a> <a name="operator%3c%3c%28%20stream%26%2c%20%45xpr%26%20%29"></a> <a name="operator%3e%3e%28%20stream%26%2c%20%4dArray%26%20%29"></a></p>
<p>The class <code>ltl::ExprBase&lt;T,N&gt;</code> is interfaced to output streams and <code>ltl::MArray&lt;T,N&gt;</code> to input and output streams using the global operators</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;T,N&gt;</div>
<div class="line">ostream&amp; operator&lt;&lt;( ostream&amp; os, const ExprBase&lt;T,N&gt;&amp; A );</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;T,N&gt;</div>
<div class="line">istream&amp; <a class="code" href="a00221.html#ga870b09c65d61d06f67a984c0a88ee904">operator&gt;&gt;</a>( istream&amp; is, MArray&lt;T,N&gt;&amp; A );</div>
</div><!-- fragment --><p>These are defined in the file <code>&lt;<a class="el" href="a00196.html">ltl/marray_io.h</a>&gt;</code> which you will have to additionally include.</p>
<p>The output of <code>operator&lt;&lt;</code> is exactly what <code>operator&gt;&gt;</code> expects as input, so you can use the latter to read what you have written using the former. The rank has to be known a priori when reading from <code>operator&lt;&lt;</code>. The lengths and index ranges are read from the stream. The format generated is human readable and can also serve as pretty printing for <code>MArrays</code>. Each dimension is wrapped in brackets and indented.</p>
<p>For example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00194.html">ltl/marray.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00196.html">ltl/marray_io.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">MArray&lt;float,2&gt; A( Range(-3,3), Range(1,3) );</div>
<div class="line">MArray&lt;float,2&gt; B;</div>
<div class="line">A = 1;</div>
<div class="line"></div>
<div class="line">ofstream os;</div>
<div class="line">os.open( <span class="stringliteral">&quot;foo&quot;</span> );</div>
<div class="line">os &lt;&lt; A;</div>
<div class="line"></div>
<div class="line">ifstream is;</div>
<div class="line">is.open( <span class="stringliteral">&quot;foo&quot;</span> );</div>
<div class="line">is &gt;&gt; B;</div>
<div class="line"></div>
<div class="line">cout &lt;&lt; B &lt;&lt; endl; </div>
</div><!-- fragment --><p>And here's the programs output:</p>
<pre class="fragment">MArray&lt;float,2&gt; ( 7 x 3 ) : (-3,3) (1,3)
[[ 1 1 1 1 1 1 1 ]
 [ 1 1 1 1 1 1 1 ]
 [ 1 1 1 1 1 1 1 ]]
</pre><p>You can also output the result of the evaluation of an <code>MArray</code> expression directly without using a temp[orary to store the result: </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A(10), B(10);</div>
<div class="line">...</div>
<div class="line">std::cout &lt;&lt; A+sqrt(B)-1 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>To map between type names and types, see the file <code>&lt;misc/type_name.h&gt;</code>, which provides type traits for this purpose. To add the string representation of a non-primitive type, use the macro <code>LTL_TYPE_NAME:</code> </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mytype</div>
<div class="line">{ ... };</div>
<div class="line"></div>
<div class="line">LTL_TYPE_NAME(mytype, <span class="stringliteral">&quot;my type name&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="ascio_doc"></a>
Columnar ASCII Files</h1>
<p><a name="%43olumnar%20A%53%43%49%49%20%46iles"></a> <a name="A%53%43%49%49%20%49%2f%4f"></a> <a name="%52ead%20columns%20from%20A%53%43%49%49%20file"></a> <a name="%57rite%20columns%20to%20A%53%43%49%49%20file"></a> <a name="%52etrieve%20the%20comment%20header"></a></p>
<p>The class <code><a class="el" href="a00015.html" title="Columns based interface to an ASCII data file. ">ltl::AscFile</a></code> provides the interface to columnar ASCII files. It supports arbitrarily delimited columns of numbers, empty lines, comments, and reading a restricted range of lines and columns.</p>
<p><a class="el" href="a00015.html" title="Columns based interface to an ASCII data file. ">ltl::AscFile</a>( string fname, char delim=0, string comment="#" ), <a class="el" href="a00015.html" title="Columns based interface to an ASCII data file. ">ltl::AscFile</a>( string fname, int firstLine, int lastLine=-1, char delim=0, string comment="#" ): Constructors of the class <code><a class="el" href="a00015.html" title="Columns based interface to an ASCII data file. ">ltl::AscFile</a></code>.</p>
<p>Columns in the file can be separated by arbitrary characters, to read whitespace delimited files, specify <code>delim=0</code>, the default, as delimiter. Otherwise set <code>delim</code> to the delimiter char.</p>
<p>Arbitrary strings may be used as comment delimiters. Using the second constructor, the <code>firstLine</code> is the first line to be read, counting from one, <code>lastLine</code> is the last line to be read, (<code>-1</code> specifies reading until <code>EOF</code>, which is the default). When searching for the first line to be read, all nonempty and non-comment lines are counted, but they may contain arbitrary text, so they don't have to be columnar. When searching for the last line, only data rows are counted. The lines beyond the last line are not read at all.</p>
<p>int <a class="el" href="a00015.html#a98bc28c1a6385ca643e7d7a6924e2619" title="High level interface to ltl::AscFile::rows_. ">ltl::AscFile::rows()</a>, int <a class="el" href="a00015.html#af02e2aecc17bf89bcb0e94c14ca28a22" title="High level interface to ltl::AscFile::cols_. ">ltl::AscFile::cols()</a><br/>
Return the number of rows in the whole file, and the number of columns in the first data row, in the case that the complete file is read, or the number of data rows between <code>firstLine</code> and <code>lastLine</code>, i.e. <code>lastLine - firstLine + 1</code>, in case only a restricted range of lines is read. The columns are counted in the first line in the latter case.</p>
<p>MArray&lt;int,1&gt; ltl::AscFile::readIntColumn( col ), MArray&lt;float,1&gt; ltl::AscFile::readFloatColumn( col ), MArray&lt;double,1&gt; ltl::AscFile::readDoubleColumn( col )<br/>
Read a column out of the file, into an <code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code>, using either <code>int</code>, <code>float</code>, or <code>double</code> type. </p>
<div class="fragment"><div class="line">AscFile File( <span class="stringliteral">&quot;foo&quot;</span> );</div>
<div class="line">MArray&lt;float,1&gt; A = File.readFloatColumn( 3 );</div>
</div><!-- fragment --><p>MArray&lt;int,2&gt; <a class="el" href="a00015.html#a51bb4f4adb154bdf5bd4b43302d2f6f8">ltl::AscFile::readIntColumns</a>( int first=1, int last=-1 ), MArray&lt;double,2&gt; <a class="el" href="a00015.html#a3374e116442acc662086d6e86a14b40f">ltl::AscFile::readFloatColumns</a>( int first=1, int last=-1 ), MArray&lt;double,2&gt; <a class="el" href="a00015.html#a3449fe5f27ffcf39c55503878e2df4a0">ltl::AscFile::readDoubleColumns</a>( int first=1, int last=-1 )<br/>
Read a range of columns into a 2-dimensional <code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code>. The default parameters read from the first to the last column, i.e. </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A = a.readFloatColumns( 1, a.cols() );</div>
</div><!-- fragment --><p> and </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A = a.readFloatColumns();</div>
</div><!-- fragment --><p> are identical.</p>
<p>For reading data into C-style arrays and STL containers, the following overloaded template methods are provided:</p>
<p>template&lt;class T&gt; int ltl::AscFile::readColumn( int col, T* &amp;carray )<br/>
Read a single column into a C-style array. The memory is allocated using <code>malloc</code>.</p>
<p>template&lt;class T&gt; int ltl::AscFile::readColumn( int col, T&amp; container )<br/>
Read a single column into an arbitrary container supporting a <code>push_back</code> function. In the STL these are <code>vector</code>, <code>list</code>, <code>deque</code>, <code>queue</code>, <code>priority_queue</code>, and <code>stack</code>.</p>
<p>To retrieve a commented header the <code><a class="el" href="a00015.html#ab50cd959546f84fa4780a1f0b1faab66">ltl::AscFile::getHeader</a></code> function is supplied.</p>
<p>int <a class="el" href="a00015.html#ab50cd959546f84fa4780a1f0b1faab66">ltl::AscFile::getHeader</a>( vector&lt;string&gt;&amp; v, bool keepcs=false )<br/>
Retrieves the commented header from the file in the <code>vector&lt;string&gt;</code> <code>v</code> and return the number of lines read. The <code>keepcs</code> boolean controls whether the leading comment string is stripped from the returned strings.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00075.html" title="Exception indicating problems with ASCII I/O. ">ltl::IOException</a></td><td>These methods throw an object of type <code><a class="el" href="a00075.html" title="Exception indicating problems with ASCII I/O. ">ltl::IOException</a></code> on error. This exception is derived from <code>std::exception</code>.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="fitsio_doc"></a>
FITS File I/O</h1>
<p><a name="%46%49%54%53%20%46ile%20%49%2f%4f"></a></p>
<h2><a class="anchor" id="fitsstd_doc"></a>
Standards And Restrictions</h2>
<p>The FITS files must conform to FITS definition NOST 100-2.0 with additional restrictions when syntax checking is on (see below).</p>
<ul>
<li>Extensions are only partially supported until now, i.e. you can read and write image extensions as well as read binary tables. </li>
<li><code>DATE</code> will be reset with every <code>writeHeader()</code> call (i.e. when writing file). </li>
<li><code>ORIGIN</code> will be reset when writing, string can be set (see below). </li>
<li><code>BLOCKED</code> will discarded when writing </li>
<li><code>EPOCH</code> will be transformed to <code>EQUINOX</code> if not already present, and discarded when writing. </li>
<li><code>BSCALE</code> and <code>BZERO</code> will be applied when reading data, but ignored when writing; since <code>FitsOut</code> erases those cards in construction they have to be set and handled by the user if needed. </li>
<li><code>BLANK</code> is not applied when reading data, the user has to take care of it; it will be discarded when writing <code>BITPIX</code> &lt; 0 (floating point) data . </li>
<li><code>CTYPEn</code>, <code>CRPIXn</code>, <code>CRVAln</code>, <code>CDELTn</code>, <code>CROTAn</code> are ignored when reading, <code>n &gt; naxis</code> erased when writing.</li>
</ul>
<p>The header will be reformatted to NOST 100-2.0 recommendation: Mandatories first, Array keys, <code>DATE</code>, other reserved keys, other keys, <code>COMMENT</code>, <code>HISTORY</code>, (junk keys,) <code>END</code>. Junk keys are keywords with a questionable, but not completely wrong syntax (i.e. other than standard commentary keywords like <code>HIERARCH</code>, <code>DATE</code> keywords with wrong syntax.</p>
<p>To use LTL FITS I/O facilities include</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00180.html">ltl/fitsio.h</a>&gt;</span> </div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></td><td>On errors a <code><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></code> indicating the error is thrown. This exception is derived from <code>std::exception</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="fitsin_doc"></a>
Reading FITS Files</h2>
<p><a name="%52eading%20%46%49%54%53%20%46iles"></a> <a name="%46its%49n"></a> <a name="%43lass%20ltl%3a%3a%46its%49n"></a></p>
<p>To read FITS files, use the class <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code>. A short description follows:</p>
<div class="fragment"><div class="line"><a class="code" href="a00051.html#aecce91955d7d40190696d456fb50786f">ltl::FitsIn::FitsIn</a>( <span class="keywordtype">string</span> file, quiet=<span class="keyword">false</span>, ignore_header=<span class="keyword">false</span> );</div>
</div><!-- fragment --><p> Construct a <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code> instance for reading from file named <code>file</code>. To turn off warnings on <code>stderr</code> one may set <code>quiet = true</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd><code>ignore_header = true</code> will cause all cards except the mandatory cards to be treated as junk cards, i.e. no syntax checking is performed. Caveat: <code>BSCALE</code> and <code>BZERO</code> will be ignored in this case!</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></td><td>If the file is unreadable for whatever reason, a <code><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></code> indicating the error is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Some shortcuts to read mandatory keywords and often used keywords:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="a00050.html#abb0f26286810eb9cb480c908908bc251">ltl::FitsIn::getBitpix</a>();</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="a00050.html#a846d7f0cbffa8834b79a49460a524737">ltl::FitsIn::getNaxis</a>();</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="a00050.html#a846d7f0cbffa8834b79a49460a524737">ltl::FitsIn::getNaxis</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> axis );</div>
</div><!-- fragment --><p> Shortcuts to obtain the values of <code>BITPIX</code>, <code>NAXIS</code>, and <code>NAXISn</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="a00050.html#abf20685b1cd48018d281393426d0c458">ltl::FitsIn::getBscale</a>();</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="a00050.html#a0ea35d48a2383f3abd2622976fe74ee3">ltl::FitsIn::getBzero</a>();</div>
</div><!-- fragment --><p> Shortcuts to obtain the values of <code>BSCALE</code> and <code>BZERO</code>.</p>
<dl class="section user"><dt>Some shortcuts to obtain information:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00051.html#a2e1e7682c73bd45f6b1e6816a912ccf6">ltl::FitsIn::describeSelf</a>( ostream&amp; os );</div>
</div><!-- fragment --><p> Print a short summary of the file to be read on given ostream: filename, <code>BITPIX</code>, <code>NAXIS</code>, and <code>naxis</code> parameters.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="a00050.html#af4aa1b520f086e26a9fcdb8a3d089fdc">ltl::FitsIn::getBytpix</a>();</div>
</div><!-- fragment --><p> Gives the number of bytes per pixel.</p>
<div class="fragment"><div class="line">off_t <a class="code" href="a00050.html#ae2003014816ccc966691e879e5f6fef9">ltl::FitsIn::getDataOffset</a>();</div>
</div><!-- fragment --><p> Gives the offset to the beginning of the data segment, i.e. the total length of the header in bytes.</p>
<div class="fragment"><div class="line">off_t <a class="code" href="a00050.html#a4c012824073e0b9c2ca9d4000b3da9c7">ltl::FitsIn::getDataLength</a>();</div>
</div><!-- fragment --><p> Gives the number of <em>bytes</em> in the data segment.</p>
<div class="fragment"><div class="line"><a class="code" href="a00117.html">util::Region</a> <a class="code" href="a00050.html#adde4b4a77f2a8a66e2bbda8f6c41494c">ltl::FitsIn::getFullRegion</a>();</div>
</div><!-- fragment --><p> Return a Region object displaying the NAXIS settings.</p>
<dl class="section user"><dt>Read header cards.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></td><td>If a keyword cannot be found a <code><a class="el" href="a00046.html" title="Exception indicating problems with FITS I/O. ">ltl::FitsException</a></code> is thrown.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code" href="a00050.html#a11c4fb5bd10b7368ede61763febd6c36">ltl::FitsIn::adjustKeyword</a>( <span class="keywordtype">string</span> keyword );</div>
</div><!-- fragment --><p> Returns a keyword trimmed to 8 characters, which is required by all methods involving keywords.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code" href="a00050.html#ab9eb1e6d00dc10f020556b424fac57ef">ltl::FitsIn::getString</a>( <span class="keywordtype">string</span> keyword );</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="a00050.html#aded43bd07936f5f5c2802c2354ecf04d">ltl::FitsIn::getBool</a>( <span class="keywordtype">string</span> keyword );</div>
<div class="line"><span class="keywordtype">long</span> <a class="code" href="a00050.html#ab9496ce13eed601d456eb47d05f92d9d">ltl::FitsIn::getInt</a>( <span class="keywordtype">string</span> keyword );</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="a00050.html#a6b8c395d4b6d89bb0b25e64920c32cf6">ltl::FitsIn::getFloat</a>( <span class="keywordtype">string</span> keyword );</div>
</div><!-- fragment --><p> Get the value of a keyword.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> isFixed( <span class="keywordtype">string</span> keyword );</div>
</div><!-- fragment --><p> Returns <code>true</code> if the card is in fixed format.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code" href="a00050.html#a5ce52e3ca3a7b6412877e3e37dd72ef4">ltl::FitsIn::getComment</a>( <span class="keywordtype">string</span> keyword );</div>
</div><!-- fragment --><p> Retrieve the comment for the given keyword.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code" href="a00050.html#a5ce52e3ca3a7b6412877e3e37dd72ef4">ltl::FitsIn::getComment</a>();</div>
<div class="line"><span class="keywordtype">string</span> <a class="code" href="a00050.html#a880db04f840e4c7c7f4f7e933de6032a">ltl::FitsIn::getHistory</a>();</div>
</div><!-- fragment --><p> Get all <code>COMMENT</code> or <code>HISTORY</code> lines as a string. The individual lines are separated by newline characters.</p>
<dl class="section user"><dt>Specifying how much data to read and reading data:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00051.html#a9b1081c0af6a0749f5a77bdf8f9c4743">ltl::FitsIn::setRegion</a>( <a class="code" href="a00117.html">util::Region</a> region );</div>
</div><!-- fragment --><p> Set the <a class="el" href="a00117.html" title="To represent geometries or subarrays of N-dimensional arrays. ">util::Region</a> <code>region</code> of the file to be read.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00051.html#add72f96b3cd24b289e5bbd79886bb3c2">ltl::FitsIn::resetRegion</a>();</div>
</div><!-- fragment --><p> Reset to full data.</p>
<div class="fragment"><div class="line"><a class="code" href="a00051.html">ltl::FitsIn</a>&amp; <a class="code" href="a00221.html#ga870b09c65d61d06f67a984c0a88ee904">operator&gt;&gt;</a>( <a class="code" href="a00051.html">ltl::FitsIn</a>&amp; in, <a class="code" href="a00091.html">ltl::MArray&lt;T,N&gt;</a>&amp; A );</div>
</div><!-- fragment --><p> Read data from the active region in the FITS file <code>in</code> into the <code>MArray A</code>.</p>
<p>If the <code>A</code> has no memory allocated yet, the whole active region is read and new memory is allocated to hold the data. If <code>A</code> already points to a valid memory FitsIn getExtension(const string&amp; xtension, const string&amp; extname, const int extver = 0, const int extlevel = 0); ! Return FitsIn object holding <em>extno</em> 's extension (get by sequential number). FitsIn getExtension(const size_t extno); ! Return the next extension. virtual FitsIn getNextExtension(); chunk, only as much data is read as will fit into <code>A</code>. The next call to <code>operator&gt;&gt;</code> will read the next chunk of data. Tiling is done along <code>NAXIS1</code> first, then <code>NAXIS2</code>, etc., in a "rectangular" pattern. The user is responsible for choosing appropriate chunk sizes, such that the resulting tiling will cover the whole data.</p>
<p>Reading a whole FITS file into an <code>MArray</code> is, therefore, pretty easy:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A;   <span class="comment">// we will read a 2-dim image, BITPIX=-32</span></div>
<div class="line">FitsIn FitsFile( <span class="stringliteral">&quot;foo.fits&quot;</span> )</div>
<div class="line">FitsFile &gt;&gt; A;</div>
</div><!-- fragment --><p>Internally, reading the data segment of a FITS file into <code>MArrays</code> is done by mapping the file into memory using <code>mmap()</code>. The mapping is done when the first read occurs. In order to free address space prior to destruction of the <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code> object one can use </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00051.html#aad6596908514e4792c5d528ce04a7339">ltl::FitsIn::freeData</a>();</div>
</div><!-- fragment --><h2><a class="anchor" id="extin_doc"></a>
Reading Extensions</h2>
<p><a name="%52eading%20%46%49%54%53%20%45xtensions"></a> <a name="%46its%45xtension%49n"></a> <a name="%43lass%20ltl%3a%3a%46its%45xtension%49n"></a> To read FITS extensions open the file with </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00048.html">ltl::FitsExtensionIn</a>( <span class="keywordtype">string</span> file, quiet=<span class="keyword">false</span>, ignore_header=<span class="keyword">false</span> );</div>
</div><!-- fragment --><p> instead of a simple <a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a>.</p>
<p>You can access the primary header and data segment by using the Extension object in the same way as the FitsIn object. To actually get access to the extension header and data you call one of the following methods. </p>
<div class="fragment"><div class="line"><span class="comment">// Return FitsIn object holding extension of type \e XTENSION with name \e EXTNAME</span></div>
<div class="line"><span class="comment">// and optional version \e EXTVER and level \e EXTLEVEL (get by name).</span></div>
<div class="line"><a class="code" href="a00051.html">ltl::FitsIn</a> <a class="code" href="a00048.html#a1741da9862fbbfdc98e1474ca667fe1a">ltl::FitsExtensionIn::getExtension</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; xtension, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; extname,</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> extver = 0, <span class="keyword">const</span> <span class="keywordtype">int</span> extlevel = 0);</div>
<div class="line"><span class="comment">// Return FitsIn object holding \e extno &#39;s extension (get by sequential number).</span></div>
<div class="line"><a class="code" href="a00051.html">ltl::FitsIn</a> <a class="code" href="a00048.html#a1741da9862fbbfdc98e1474ca667fe1a">ltl::FitsExtensionIn::getExtension</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> extno);</div>
<div class="line"><span class="comment">// Return the next extension.</span></div>
<div class="line"><a class="code" href="a00051.html">ltl::FitsIn</a> <a class="code" href="a00048.html#ac0cab292ab76bfdfc4da89520e16a02f">ltl::FitsExtensionIn::getNextExtension</a>();</div>
</div><!-- fragment --><p> For Image Extensions you just go ahead and use the returned object as a FitsIn object. For BinTable Extensions you have to create a </p>
<div class="fragment"><div class="line"><a class="code" href="a00043.html">ltl::FitsBinTableIn</a>(<span class="keyword">const</span> FitsIn&amp; other);</div>
</div><!-- fragment --><p> of the <a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn()</a> object returned by any of the <a class="el" href="a00048.html" title="Primary HDU and extensions in one object. Look into test/testfitsextensionio.cpp for examples...">ltl::FitsExtensionIn()</a> methods. Use one of the </p>
<div class="fragment"><div class="line">MArray&lt;T, N&gt; <a class="code" href="a00043.html#a18eb0d399b582ec50c728e4fb27511e6">ltl::FitsBinTableIn::readColumn</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; ttype, <span class="keyword">const</span> <span class="keywordtype">int</span> startrow = 1, <span class="keyword">const</span> <span class="keywordtype">int</span> endrow = 0);</div>
<div class="line">MArray&lt;T, N&gt; <a class="code" href="a00043.html#a18eb0d399b582ec50c728e4fb27511e6">ltl::FitsBinTableIn::readColumn</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> colno, <span class="keyword">const</span> <span class="keywordtype">int</span> startrow = 1, <span class="keyword">const</span> <span class="keywordtype">int</span> endrow = 0);</div>
</div><!-- fragment --><p> methods to read a column by name or number into an MArray. Default is to read a whole column, but you may specify the range.</p>
<h2><a class="anchor" id="fitsout_doc"></a>
Writing FITS Files</h2>
<p><a name="%57riting%20%46%49%54%53%20%46iles"></a> <a name="%46its%4fut"></a> <a name="%43lass%20ltl%3a%3a%46its%4fut"></a></p>
<div class="fragment"><div class="line"><a class="code" href="a00053.html#afac35965e3aaf82d38d56b0a80ee9df2">ltl::FitsOut::FitsOut</a>( <span class="keywordtype">string</span> filename, <span class="keywordtype">bool</span> quiet=<span class="keyword">false</span> );</div>
<div class="line"><a class="code" href="a00053.html#afac35965e3aaf82d38d56b0a80ee9df2">ltl::FitsOut::FitsOut</a>( <span class="keywordtype">string</span> filename, FitsHeader&amp; header, <span class="keywordtype">bool</span> quiet=<span class="keyword">false</span> );</div>
</div><!-- fragment --><p> Construct a <code><a class="el" href="a00053.html" title="Writing FITS files. ">ltl::FitsOut</a></code> object, optionally copying the header information from <code>header</code>.</p>
<p>If no header is given, a default will be created, containing only mandatories. Those will be adjusted to reflect what is written when the actual writing is performed.</p>
<p>Note that <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code> is derived from <code><a class="el" href="a00050.html" title="Representation of a complete FITS header. Holds also header I/O methods. ">ltl::FitsHeader</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00053.html#afe56a0b6d6f505fbc3907a1e982875b6">ltl::FitsOut::setBitpixOut</a>( <span class="keywordtype">int</span> bitpix );</div>
</div><!-- fragment --><p> Set <code>BITPIX</code> explicitly. If you do this, type conversion to the type specified by <code>BITPIX</code> will be performed when writing. If you do not call this method, <code>BITPIX</code> will be set according to what go passed when actually performing the write operation, and no type conversion will be performed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00053.html#ac489e15b5fbd341d9d7af74b473c9463">ltl::FitsOut::setOrigin</a>( <span class="keywordtype">string</span> origin );</div>
</div><!-- fragment --><p> Set the <code>ORIGIN</code> keyword, defaults to "LTL FITS IO class".</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00050.html#ad45a81b162fd58953e69626dc88162ce">ltl::FitsOut::addComment</a>( <span class="keywordtype">string</span> comment );</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00050.html#ac72ef124949eeefde307ed38061d2d2d">ltl::FitsOut::addHistory</a>( <span class="keywordtype">string</span> history );</div>
</div><!-- fragment --><p> Add comment or history text. The text will be automatically wrapped and added to the list of <code>COMMENT</code> or <code>HISTORY</code> keywords.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00050.html#ab3c02863a0879a0ec65d2182d6d0e777">ltl::FitsOut::addValueCard</a>( <span class="keywordtype">string</span> keyword, <span class="keywordtype">string</span> value, <span class="keywordtype">string</span> comment=<span class="charliteral">&#39;&#39;&#39;</span><span class="stringliteral">&#39; );</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">void ltl::FitsOut::addValueCard( string keyword, bool value, string comment=&#39;</span><span class="charliteral">&#39;&#39;&#39;</span> );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="a00050.html#ab3c02863a0879a0ec65d2182d6d0e777">ltl::FitsOut::addValueCard</a>( <span class="keywordtype">string</span> keyword, <span class="keywordtype">int</span> value, <span class="keywordtype">string</span> comment=<span class="charliteral">&#39;&#39;&#39;</span><span class="stringliteral">&#39; );</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">void ltl::FitsOut::addValueCard( string keyword, double value, string comment=&#39;</span><span class="charliteral">&#39;&#39;&#39;</span> );</div>
</div><!-- fragment --><p> Add a card with a value of given type to the header.</p>
<p>You may also use the methods for reading keywords described above in <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00050.html#a39bfe097e5261bf567ba56ac57a5250d">ltl::FitsOut::eraseCard</a>( <span class="keywordtype">string</span> keyword );</div>
</div><!-- fragment --><p> Remove card from header.</p>
<p>Actually writing data from an <code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code> in FITS format:</p>
<div class="fragment"><div class="line"><a class="code" href="a00053.html">ltl::FitsOut</a>&amp; operator&lt;&lt;( ltl::FitsOut&amp; out, ltl::MArray&lt;T,N&gt;&amp; A );</div>
</div><!-- fragment --><p> Write data from <code>A</code> to FITS format file. If <code>BITPIX</code> has not been set explicitly using <code><a class="el" href="a00053.html#afe56a0b6d6f505fbc3907a1e982875b6" title="Override automatic BITPIX setting with argument. ">ltl::FitsOut::setBitpixOut()</a></code>, it will be set according to the type <code>T</code> of the <code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code>, otherwise, data of <code>A</code> will be converted to the value specified by <code><a class="el" href="a00053.html#afe56a0b6d6f505fbc3907a1e982875b6" title="Override automatic BITPIX setting with argument. ">ltl::FitsOut::setBitpixOut()</a></code>.</p>
<p>The same options are possible as in reading using <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a></code>, explained above.</p>
<p>Example writing an image to a FITS file: </p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; Image( nx, ny );</div>
<div class="line">Image = ... ;</div>
<div class="line"></div>
<div class="line">FitsOut out( <span class="stringliteral">&quot;foo.fits&quot;</span> );</div>
<div class="line">out &lt;&lt; Image;</div>
</div><!-- fragment --><p>If you want to write very large FITS-files (i.e. very large primary data segments; for Extensions see further down below) you can split the writing into pieces. For an example look into test/testfitsio.cpp and search for void testwriteregion( void )</p>
<p>For convenience, in case you want to copy (parts of) a FITS file and optionally only want to change header information, there is a version of <code>operator&lt;&lt;</code> using only <code><a class="el" href="a00053.html" title="Writing FITS files. ">ltl::FitsOut</a></code> and <code><a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a>:</code> </p>
<div class="fragment"><div class="line"><a class="code" href="a00053.html">ltl::FitsOut</a>&amp; <a class="code" href="a00221.html#ga873e38e07cc0132059101590af944976">operator&lt;&lt;</a>( <a class="code" href="a00053.html">ltl::FitsOut</a>&amp; out, <a class="code" href="a00051.html">ltl::FitsIn</a>&amp; in );</div>
</div><!-- fragment --><p> Copy data from <code>in</code> to <code>out</code>. Regions in <code>in</code> will be respected, so that portions of files can be copied.</p>
<p>For example: </p>
<div class="fragment"><div class="line">FitsIn infile( <span class="stringliteral">&quot;foo.fits&quot;</span> );</div>
<div class="line">FitsOut outfile( <span class="stringliteral">&quot;bar.fits&quot;</span>, infile );  <span class="comment">// infile argument copies header</span></div>
<div class="line">                                        <span class="comment">// immediately, so we can manipulate,</span></div>
<div class="line">                                        <span class="comment">// it is not necessary</span></div>
<div class="line"></div>
<div class="line">infile.setRegion( region );  <span class="comment">// just optionally</span></div>
<div class="line"></div>
<div class="line">outfile.addHistory( <span class="stringliteral">&quot;File copied by me ...&quot;</span> );</div>
<div class="line"></div>
<div class="line">outfile &lt;&lt; infile; <span class="comment">// or</span></div>
<div class="line">infile &gt;&gt; outfile;</div>
<div class="line"><span class="comment">// BSCALE and BZERO will be set according to the infile</span></div>
</div><!-- fragment --><h2><a class="anchor" id="extout_doc"></a>
Writing Extensions</h2>
<p>For now only writing of image extensions is supported. FITS Extension files are written sequentially. Example:</p>
<div class="fragment"><div class="line">MArray&lt;float,2&gt; A(100,100);</div>
<div class="line">MArray&lt;int,3&gt; B(3,20,20);</div>
<div class="line">FitsExtensionOut feo(<span class="stringliteral">&quot;testextensionio.fits&quot;</span>);</div>
<div class="line">feo.addValueCard(<span class="stringliteral">&quot;TESTTEST&quot;</span>, <span class="stringliteral">&quot;This is a test&quot;</span>);</div>
<div class="line">feo.addValueCard(<span class="stringliteral">&quot;TEST1234&quot;</span>, 1.234);</div>
<div class="line">feo &lt;&lt; <a class="code" href="a00214.html#a57d12768178ef45fa293364c60e204fa">emptyData</a>; <span class="comment">// primary with no data</span></div>
<div class="line">feo &lt;&lt; A;         <span class="comment">// 1st extension with data and still the same header</span></div>
<div class="line">feo = some_other_FitsHeader_object;</div>
<div class="line">feo &lt;&lt; <a class="code" href="a00214.html#a57d12768178ef45fa293364c60e204fa">emptyData</a>; <span class="comment">// 2nd extension with no data and new header</span></div>
<div class="line">feo &lt;&lt; B;  <span class="comment">// 3rd extension with data and also &quot;some_other_FitsHeader&quot;</span></div>
</div><!-- fragment --><p> Use <a class="el" href="a00051.html" title="Reading FITS data segment, reading and modifying FITS header. ">ltl::FitsIn</a> as some_other_FitsHeader_object if you want to copy a header from an existing file. Use <a class="el" href="a00053.html" title="Writing FITS files. ">ltl::FitsOut</a> to construct a new header from scratch (the FitsOut object will not create a file unless you feed an MArray into it).</p>
<h2><a class="anchor" id="fitsfeat_doc"></a>
Additional Features</h2>
<p>You can use the FITS I/O facilities with C-style arrays, too, without using <code>MArrays</code>.</p>
<p>You may use any FITS I/O methods with <code><a class="el" href="a00178.html">ltl/fits.h</a></code> instead of <code><a class="el" href="a00180.html">ltl/fitsio.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">// include fitsio without LTL MArrays </span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00178.html">fits.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// get data arrays of type T and selected region</span></div>
<div class="line">T* infile.getDataArray( T dummy );</div>
<div class="line"></div>
<div class="line"><span class="comment">// read into container using an iterator T</span></div>
<div class="line">infile.readDataArray( T iterator );</div>
<div class="line"></div>
<div class="line"><span class="comment">// write from container </span></div>
<div class="line">outfile.setBscale( infile.getBscale() ); <span class="comment">// optionally set</span></div>
<div class="line">outfile.setBzero( infile.getBzero() ); <span class="comment">// optionally set</span></div>
<div class="line">outfile.openData( <span class="keywordtype">int</span> newbitpix, <span class="keyword">class</span> Region region ); <span class="comment">// or</span></div>
<div class="line"><span class="keywordtype">int</span> newnaxis_i [newnaxis] = { NAXIS1, ..., NAXIS_newnaxis };</div>
<div class="line">outfile.openData( <span class="keywordtype">int</span> newbitpix, <span class="keywordtype">int</span> newnaxis, <span class="keywordtype">int</span> * newnaxis_i );</div>
<div class="line"><span class="comment">// prepare for data write,</span></div>
<div class="line"><span class="comment">// the NAXIS parameters maybe extracted from a Region or be set explicitly </span></div>
<div class="line">outfile.writeDataArray( T iterator );</div>
<div class="line">outfile.closeData();</div>
</div><!-- fragment --><p>Additionally, you can perform I/O operations on a per pixel basis:<br/>
This is still under development. <code><a class="el" href="a00051.html#a9b1081c0af6a0749f5a77bdf8f9c4743" title="Select region of interest in data segment. ">ltl::FitsIn::setRegion()</a></code> is ignored for this set of methods. You can use <code>setPosition()</code> and <code>getPosition()</code> instead. No range checking is performed, you must prevent reading past <code>EOF</code> yourself.</p>
<div class="fragment"><div class="line"><span class="comment">// read pixel from stream:</span></div>
<div class="line">infile &gt;&gt; T value;</div>
<div class="line"></div>
<div class="line"><span class="comment">// reset stream pointer to start of data </span></div>
<div class="line">infile.resetPosition();</div>
<div class="line"></div>
<div class="line"><span class="comment">// set stream pointer to position </span></div>
<div class="line">infile.setPosition( <span class="keywordtype">size_t</span> offset );</div>
<div class="line"></div>
<div class="line"><span class="comment">// get offset from start of data </span></div>
<div class="line">ptrdiff_t offset = infile.getPosition();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// open output stream </span></div>
<div class="line">outfile.openData( <span class="keywordtype">int</span> newbitpix, <span class="keywordtype">int</span> newnaxis, <span class="keywordtype">int</span> * newnaxis_i );</div>
<div class="line"></div>
<div class="line"><span class="comment">// write pixel to stream:</span></div>
<div class="line">outfile &lt;&lt; T value;</div>
<div class="line"></div>
<div class="line"><span class="comment">// reset stream pointer to start of data </span></div>
<div class="line">outfile.resetPosition();</div>
<div class="line"></div>
<div class="line"><span class="comment">// set stream pointer to position </span></div>
<div class="line">outfile.setPosition( <span class="keywordtype">size_t</span> offset );</div>
<div class="line"></div>
<div class="line"><span class="comment">// get offset from start of data </span></div>
<div class="line">ptrdiff_t offset = outfile.getPosition();</div>
<div class="line"></div>
<div class="line"><span class="comment">// close output stream </span></div>
<div class="line">outfile.closeData();</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 11 2015 14:54:49 for LTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
