<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LTL: MArray Expression Template Internals</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="ltl_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LTL
   &#160;<span id="projectnumber">2.0.x</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MArray Expression Template Internals<div class="ingroups"><a class="el" href="a00216.html">The Class MArray</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00176"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">expr_base.h</a></td></tr>
<tr class="memdesc:a00176"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the base class for all operands in expression templates. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">ltl::ExprNode&lt; A, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node in the expression parse tree. Every expression in ultimately represented by this class.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">ltl::ExprBinopNode&lt; A, B, Op, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operation node in the expression parse tree.  <a href="a00038.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">ltl::ExprUnopNode&lt; A, Op, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operation node in the expression parse tree.  <a href="a00041.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">ltl::ExprLiteralNode&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node in the expression parse tree representing a literal number.  <a href="a00039.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">ltl::ExprBase&lt; Derived_T, N_Dims &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga83e41ca19475726d02eac41075c793bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga83e41ca19475726d02eac41075c793bb">BINOP_AA</a>(operator, op)</td></tr>
<tr class="memdesc:ga83e41ca19475726d02eac41075c793bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the global binary functions/operators for <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a> expressions, version for 2 MArray operands, overloaded versions below.  <a href="#ga83e41ca19475726d02eac41075c793bb">More...</a><br/></td></tr>
<tr class="separator:ga83e41ca19475726d02eac41075c793bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801347b8b4a41378bb910a350e230a0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga801347b8b4a41378bb910a350e230a0d">UNOP_E</a>(operator, op)</td></tr>
<tr class="memdesc:ga801347b8b4a41378bb910a350e230a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the global unary operators, overloaded versions for marray operand.  <a href="#ga801347b8b4a41378bb910a350e230a0d">More...</a><br/></td></tr>
<tr class="separator:ga801347b8b4a41378bb910a350e230a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03bab10ac443684fc904f207a3f1fa25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga03bab10ac443684fc904f207a3f1fa25">DECLARE_UNOP</a>(operation, opname)</td></tr>
<tr class="memdesc:ga03bab10ac443684fc904f207a3f1fa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unary (built-in) operator available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary operator <code>operation</code>. The return type is the standard C type-promoted result of the operation on built in scalar types.  <a href="#ga03bab10ac443684fc904f207a3f1fa25">More...</a><br/></td></tr>
<tr class="separator:ga03bab10ac443684fc904f207a3f1fa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33e5f013a2c7cd8a46f95b1b0f09513"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#gaf33e5f013a2c7cd8a46f95b1b0f09513">DECLARE_UNARY_FUNC_</a>(function)</td></tr>
<tr class="memdesc:gaf33e5f013a2c7cd8a46f95b1b0f09513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make any unary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary function <code>function</code>. The return type may be different than the operand type.  <a href="#gaf33e5f013a2c7cd8a46f95b1b0f09513">More...</a><br/></td></tr>
<tr class="separator:gaf33e5f013a2c7cd8a46f95b1b0f09513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe0485de828fb2f85ccdf897e958187"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga1fe0485de828fb2f85ccdf897e958187">DECLARE_BINARY_FUNC</a>(function, ret_type)</td></tr>
<tr class="memdesc:ga1fe0485de828fb2f85ccdf897e958187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make any user-defined binary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary function <code>function</code>. The return type may be different than the operand type.  <a href="#ga1fe0485de828fb2f85ccdf897e958187">More...</a><br/></td></tr>
<tr class="separator:ga1fe0485de828fb2f85ccdf897e958187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b6bcc7f146112cde140ef0ce2143d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga70b6bcc7f146112cde140ef0ce2143d6">DECLARE_UNARY_FUNC</a>(function, ret_type)</td></tr>
<tr class="memdesc:ga70b6bcc7f146112cde140ef0ce2143d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make any user-defined unary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary function <code>function</code>. The return type may be different than the operand type.  <a href="#ga70b6bcc7f146112cde140ef0ce2143d6">More...</a><br/></td></tr>
<tr class="separator:ga70b6bcc7f146112cde140ef0ce2143d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae14a6169d050807d72d6c779847e0fc9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gae14a6169d050807d72d6c779847e0fc9"><td class="memTemplItemLeft" align="right" valign="top">const Shape&lt; A::dims &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00258.html#gae14a6169d050807d72d6c779847e0fc9">ltl::_expr_getshape</a> (const A &amp;a, const B &amp;)</td></tr>
<tr class="memdesc:gae14a6169d050807d72d6c779847e0fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the <code>shape</code> of an expression by returning the <a class="el" href="a00119.html">ltl::Shape</a> objects on one of the <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a> operatnds.  <a href="#gae14a6169d050807d72d6c779847e0fc9">More...</a><br/></td></tr>
<tr class="separator:gae14a6169d050807d72d6c779847e0fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c5f683e0024d7a6503b78613adc8bc"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ga55c5f683e0024d7a6503b78613adc8bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00262.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00258.html#ga55c5f683e0024d7a6503b78613adc8bc">ltl::_expr_getalign</a> (const A &amp;a, const B &amp;)</td></tr>
<tr class="memdesc:ga55c5f683e0024d7a6503b78613adc8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the alignment (w.r.t. natural vector boundaries) of the operands in an expression.  <a href="#ga55c5f683e0024d7a6503b78613adc8bc">More...</a><br/></td></tr>
<tr class="separator:ga55c5f683e0024d7a6503b78613adc8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9916ceb7e7d8e7824c110cfdd82a6889"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#ga9916ceb7e7d8e7824c110cfdd82a6889">DECLARE_BINOP</a>(operation, opname)</td></tr>
<tr class="memdesc:ga9916ceb7e7d8e7824c110cfdd82a6889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a binary (built-in) operator available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary operator <code>operation</code>. The return type is the standard C type-promoted result of the operation on built in scalar types.  <a href="#ga9916ceb7e7d8e7824c110cfdd82a6889">More...</a><br/></td></tr>
<tr class="separator:ga9916ceb7e7d8e7824c110cfdd82a6889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a6ee477fe61dc91c59409e79e5f301"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html#gac1a6ee477fe61dc91c59409e79e5f301">DECLARE_BINARY_FUNC_</a>(function)</td></tr>
<tr class="memdesc:gac1a6ee477fe61dc91c59409e79e5f301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make any binary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary function <code>function</code>. The return type may be different than the operand type.  <a href="#gac1a6ee477fe61dc91c59409e79e5f301">More...</a><br/></td></tr>
<tr class="separator:gac1a6ee477fe61dc91c59409e79e5f301"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This documentation explains the internal expression template mechanism. It should not be necessary to understand all this to use the LTL.</p>
<p>The anatomy of expression templates:</p>
<p>Expressions like the right-hand side of </p>
<div class="fragment"><div class="line">*     A = A + B*C;</div>
<div class="line">*  </div>
</div><!-- fragment --><p> (with <code>A</code>, <code>B</code>, and <code>C</code> being of type <code>ltl::MArray&lt;float,1&gt;</code>) are represented by nested templated data types that capture the parse tree of the expression.</p>
<p>In this example, the expression A + B*C is represented by the type (simplified for readability) </p>
<div class="fragment"><div class="line">*     <a class="code" href="a00038.html">ltl::ExprBinopNode&lt;ltl::MArrayIterConst&lt;float, 1&gt;</a>,</div>
<div class="line">*                        <a class="code" href="a00040.html">ltl::ExprNode&lt;ltl::ExprBinopNode&lt;ltl::MArrayIterConst&lt;float, 1&gt;</a>,</div>
<div class="line">*                                                         <a class="code" href="a00093.html">ltl::MArrayIterConst&lt;float, 1&gt;</a>,</div>
<div class="line">*                                                         ltl::__ltl_TMul&lt;float, float&gt;,</div>
<div class="line">*                                                         1&gt;,</div>
<div class="line">*                                      1&gt;,</div>
<div class="line">*                        ltl::__ltl_TAdd&lt;float, float&gt;,</div>
<div class="line">*                        1&gt;</div>
<div class="line">*  </div>
</div><!-- fragment --><p> In real code, we'd want all possible parse tree nodes to be of one single type so that any expression argument can be caught by a single templated type. Therefore, each of the parse tree nodes is wrapped in a template class <code>ExprNode&lt;&gt;</code>, which forwards all calls to the parse tree node it wraps.</p>
<p>The class <code>ExprNode&lt;&gt;</code> defines an iterator-like interface that all parse tree nodes (and ultimately the iterators that parse tree nodes hold) implement. This way, a whole expression, and every sub-expression presents an iterator interface to the outside world.</p>
<p>For this to function we define </p>
<ul>
<li>A global-scope overloaded function or operator for each function or operator we wish to use in expression templates e.g., <code>operator+</code> and <code>sin()</code>. This function/operator takes types representing nodes in the parse tree as arguments and return a type representing their own node in the parse tree. For example <code>opertator+</code> for two expressions: <div class="fragment"><div class="line">*      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keywordtype">int</span> N&gt;</div>
<div class="line">*      <span class="keyword">inline</span> ExprNode&lt;ExprBinopNode&lt;ExprNode&lt;A,N&gt;,</div>
<div class="line">*                                    ExprNode&lt;B,N&gt;,</div>
<div class="line">*                                    __ltl_TAdd&lt;typename A::value_type, typename B::value_type&gt;,</div>
<div class="line">*                                    N &gt;, N &gt;</div>
<div class="line">*      operator+( <span class="keyword">const</span> ExprNode&lt;A,N&gt;&amp; a, <span class="keyword">const</span> ExprNode&lt;B,N&gt;&amp; b )</div>
<div class="line">*      {</div>
<div class="line">*         <span class="keyword">typedef</span> ExprBinopNode&lt;ExprNode&lt;A,N&gt;,</div>
<div class="line">*                               ExprNode&lt;B,N&gt;,</div>
<div class="line">*                               __ltl_TAdd&lt;typename A::value_type, typename B::value_type&gt;, N &gt;</div>
<div class="line">*         ExprT;</div>
<div class="line">*         <span class="keywordflow">return</span> ExprNode&lt;ExprT,N&gt;( ExprT(a,b) );</div>
<div class="line">*      }</div>
<div class="line">*    </div>
</div><!-- fragment --> Since we need overloaded versions for all operations, we will define macros to help set these up.</li>
</ul>
<ul>
<li>Each of these global functions encodes the operation it represents by a further template parameter of the parse tree node. This is a struct (called an applicative template) that implements the operation on scalar types via a method called <code>eval()</code>. In the above example these are <code>ltl::__ltl_TMul</code> and <code>ltl::__ltl_TAdd</code>. <code>ltl::__ltl_TAdd</code> looks like this: <div class="fragment"><div class="line">*      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div>
<div class="line">*      <span class="keyword">struct </span>__ltl_TAdd : <span class="keyword">public</span> _et_applic_base</div>
<div class="line">*      {</div>
<div class="line">*         <span class="keyword">typedef</span> <span class="keyword">typename</span> promotion_trait&lt;T1,T2&gt;::PType value_type;</div>
<div class="line">*         <span class="keyword">static</span> <span class="keyword">inline</span> value_type eval( <span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b )</div>
<div class="line">*         { <span class="keywordflow">return</span> a + b; }</div>
<div class="line">*      }</div>
<div class="line">*    </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Nodes in the parse tree implement the same interface as <a class="el" href="a00092.html">ltl::MArrayIter</a> iterators.</li>
</ul>
<p>Ultimately, the expression is evaluated by </p>
<div class="fragment"><div class="line">*    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</div>
<div class="line">*    <a class="code" href="a00091.html#a9b5163a198a8e7989a66a18125269be1">ltl::MArray&lt;float,1&gt;::operator=</a>( ExprNode&lt;E,1&gt; ).</div>
<div class="line">*  </div>
</div><!-- fragment --><p> which uses the iterator-like interface of the expression to loop over each element of the underlying (multidimensional) array structure.</p>
<p>TODO: properly document the new ET mechanism, and also all types derived from <a class="el" href="a00037.html">ExprBase</a>, e.g. MergeExpr, ... and how to add user-defined expressions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga83e41ca19475726d02eac41075c793bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BINOP_AA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">operator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the global binary functions/operators for <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a> expressions, version for 2 MArray operands, overloaded versions below. </p>
<p>Each binary function/operator takes opjects derived from <code>ExprBase</code> (<code>MArray</code>, <code>ExprNode</code>), or literals as arguments and returns a parse-tree node for the operation it represents: </p>
<div class="fragment"><div class="line">*    ExprNode &lt;ExprBinopNode &lt;A, B, Operation, NDim&gt; &gt; <span class="keyword">function</span>( A&amp; rhs, B&amp; lhs )</div>
<div class="line">*  </div>
</div><!-- fragment --><p> where <code>LHS</code> and <code>RHS</code> are of type <code>ExprBase</code> or (scalar) literals.</p>
<p>There are 8 combination of argument types for binary ops, namely:</p>
<p>array op array, <br/>
 array op scalar, <br/>
 scalar op array, <br/>
 expr op array, <br/>
 array op expr, <br/>
 expr op expr, <br/>
 scalar op expr, and <br/>
 expr op scalar. <br/>
 An overloaded function/operator template is generated by these macros for each of these cases. The literal type is assumed to be of the same type as the elements of the expr (or be type-castable to that type).</p>
<p>This might seem like it could be reduced to 3 cases by unifying the overloaded functions for array and expr to take <code>ExprBase</code> objects as arguments. However, this causes ambiguous overloads with the cases taking an arbitrary type (a scalar). </p>

</div>
</div>
<a class="anchor" id="ga801347b8b4a41378bb910a350e230a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNOP_E</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">operator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the global unary operators, overloaded versions for marray operand. </p>
<p>Each unary function/operator takes objects derived from <code>ExprBase</code> (<code><a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a></code>, <code><a class="el" href="a00040.html" title="Node in the expression parse tree. Every expression in ultimately represented by this class...">ltl::ExprNode</a></code>) as arguments and returns a parse-tree node for the operation it represents: </p>
<div class="fragment"><div class="line">*    ExprNode &lt;ExprUnopNode &lt;A, Operation, NDim&gt; &gt; <span class="keyword">function</span>( A&amp; operand )</div>
<div class="line">*  </div>
</div><!-- fragment --><p> where <code>operand</code> is of type <code>ExprBase</code>. </p>

</div>
</div>
<a class="anchor" id="ga9916ceb7e7d8e7824c110cfdd82a6889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_BINOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">operation, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opname&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a binary (built-in) operator available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary operator <code>operation</code>. The return type is the standard C type-promoted result of the operation on built in scalar types. </p>
<p>It is assumed that the name of the applicative template for the same operator is called <code>ltl::__ltl_opname</code> and that this template is defined elsewhere (<a class="el" href="a00166.html">misc/applicops.h</a> for built-in operators). </p>

</div>
</div>
<a class="anchor" id="ga03bab10ac443684fc904f207a3f1fa25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_UNOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">operation, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opname&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a unary (built-in) operator available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary operator <code>operation</code>. The return type is the standard C type-promoted result of the operation on built in scalar types. </p>
<p>It is assumed that the name of the applicative template for the same operator is called <code>ltl::__ltl_opname</code> and that this template is defined elsewhere (<a class="el" href="a00166.html">misc/applicops.h</a> for built-in operators). </p>

</div>
</div>
<a class="anchor" id="gac1a6ee477fe61dc91c59409e79e5f301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_BINARY_FUNC_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make any binary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary function <code>function</code>. The return type may be different than the operand type. </p>
<p>It is assumed that the name of the applicative template for the same function is called <code>ltl::__ltl_function</code> and that this template is defined elsewhere. (<a class="el" href="a00166.html">misc/applicops.h</a> for standard functions).</p>
<p>The function itself has to be implemented with the signature </p>
<div class="fragment"><div class="line">*    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">*    T <span class="keyword">function</span>( <span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b );</div>
<div class="line">*  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf33e5f013a2c7cd8a46f95b1b0f09513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_UNARY_FUNC_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make any unary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary function <code>function</code>. The return type may be different than the operand type. </p>
<p>It is assumed that the name of the applicative template for the same function is called <code>ltl::__ltl_function</code> and that this template is defined elsewhere (<a class="el" href="a00166.html">misc/applicops.h</a> for standard functions).</p>
<p>The function itself has to be implemented with the signature </p>
<div class="fragment"><div class="line">*    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">*    T <span class="keyword">function</span>( <span class="keyword">const</span> T&amp; a );</div>
<div class="line">*  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1fe0485de828fb2f85ccdf897e958187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_BINARY_FUNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="a00166.html#ae51111ffb69bae3b330bfaa37f355fa2">MAKE_BINAP_FUNC</a>( __ltl_##<span class="keyword">function</span>, ret_type, <span class="keyword">function</span> );     <a class="code" href="a00258.html#gac1a6ee477fe61dc91c59409e79e5f301">\</a></div>
<div class="line"><a class="code" href="a00258.html#gac1a6ee477fe61dc91c59409e79e5f301">DECLARE_BINARY_FUNC_</a>(<span class="keyword">function</span>)</div>
<div class="ttc" id="a00166_html_ae51111ffb69bae3b330bfaa37f355fa2"><div class="ttname"><a href="a00166.html#ae51111ffb69bae3b330bfaa37f355fa2">MAKE_BINAP_FUNC</a></div><div class="ttdeci">#define MAKE_BINAP_FUNC(classname, ret_type, func)</div><div class="ttdef"><b>Definition:</b> applicops.h:104</div></div>
<div class="ttc" id="a00258_html_gac1a6ee477fe61dc91c59409e79e5f301"><div class="ttname"><a href="a00258.html#gac1a6ee477fe61dc91c59409e79e5f301">DECLARE_BINARY_FUNC_</a></div><div class="ttdeci">#define DECLARE_BINARY_FUNC_(function)</div><div class="ttdoc">Make any binary function available to expression templates.This macro declares all necessary overload...</div><div class="ttdef"><b>Definition:</b> expr.h:1290</div></div>
</div><!-- fragment -->
<p>Make any user-defined binary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given binary function <code>function</code>. The return type may be different than the operand type. </p>
<p>This macro also declares and defines the applicative templates for this function. It is the only macro that needs to be called by users to make user-defined functions available to expression templates.</p>
<p>Assume you have a function like this: </p>
<div class="fragment"><div class="line">*    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">*    ret_type <span class="keyword">function</span>( <span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b );</div>
<div class="line">*  </div>
</div><!-- fragment --><p> Then using </p>
<div class="fragment"><div class="line">*    <a class="code" href="a00258.html#ga1fe0485de828fb2f85ccdf897e958187">DECLARE_BINARY_FUNC</a>(<span class="keyword">function</span>, ret_type);</div>
<div class="line">*  </div>
</div><!-- fragment --><p> This function will be usable in expression templates. </p>

</div>
</div>
<a class="anchor" id="ga70b6bcc7f146112cde140ef0ce2143d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_UNARY_FUNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="a00166.html#a66618409fe89b6caa9c9ab4aa3649518">MAKE_UNAP_FUNC</a>( __ltl_##<span class="keyword">function</span>, ret_type, <span class="keyword">function</span> );       <a class="code" href="a00258.html#gaf33e5f013a2c7cd8a46f95b1b0f09513">\</a></div>
<div class="line"><a class="code" href="a00258.html#gaf33e5f013a2c7cd8a46f95b1b0f09513">DECLARE_UNARY_FUNC_</a>(<span class="keyword">function</span>)</div>
<div class="ttc" id="a00258_html_gaf33e5f013a2c7cd8a46f95b1b0f09513"><div class="ttname"><a href="a00258.html#gaf33e5f013a2c7cd8a46f95b1b0f09513">DECLARE_UNARY_FUNC_</a></div><div class="ttdeci">#define DECLARE_UNARY_FUNC_(function)</div><div class="ttdoc">Make any unary function available to expression templates.This macro declares all necessary overloade...</div><div class="ttdef"><b>Definition:</b> expr.h:1319</div></div>
<div class="ttc" id="a00166_html_a66618409fe89b6caa9c9ab4aa3649518"><div class="ttname"><a href="a00166.html#a66618409fe89b6caa9c9ab4aa3649518">MAKE_UNAP_FUNC</a></div><div class="ttdeci">#define MAKE_UNAP_FUNC(classname, ret_type, op)</div><div class="ttdef"><b>Definition:</b> applicops.h:132</div></div>
</div><!-- fragment -->
<p>Make any user-defined unary function available to expression templates.This macro declares all necessary overloaded operators to build the parse tree for a given unary function <code>function</code>. The return type may be different than the operand type. </p>
<p>This macro also declares and defines the applicative templates for this function. It is the only macro that needs to be called by users to make user-defined functions available to expression templates.</p>
<p>Assume you have a function like this: </p>
<div class="fragment"><div class="line">*    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">*    ret_type <span class="keyword">function</span>( <span class="keyword">const</span> T&amp; a );</div>
<div class="line">*  </div>
</div><!-- fragment --><p> Then using </p>
<div class="fragment"><div class="line">*    <a class="code" href="a00258.html#ga1fe0485de828fb2f85ccdf897e958187">DECLARE_BINARY_FUNC</a>(<span class="keyword">function</span>, ret_type);</div>
<div class="line">*  </div>
</div><!-- fragment --><p> This function will be usable in expression templates. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae14a6169d050807d72d6c779847e0fc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Shape&lt;A::dims&gt;* ltl::_expr_getshape </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the <code>shape</code> of an expression by returning the <a class="el" href="a00119.html">ltl::Shape</a> objects on one of the <a class="el" href="a00091.html" title="A dynamic N-dimensional array storing objects of type T. ">ltl::MArray</a> operatnds. </p>
<p>Determine the <code>shape</code> of an expression</p>
<p>When determining the <code>shape</code> of an expression it is sufficient to return any one <code>shape</code> object from any one of the MArrays in the expression since we know they will all be the conformable. However, we must make sure that we do not ask e.g. a literal constant for a shape ...</p>
<p>In the general case, just use the LHS <a class="el" href="a00119.html">Shape</a> ... We will provide partial specializations for the cases where one of the operands does not have a shape and return the other instead. </p>

<p>Referenced by <a class="el" href="a00038.html#a1dfa05fa2ab14606a132a1bd99bc777c">ltl::ExprBinopNode&lt; A, B, Op, N &gt;::shape()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55c5f683e0024d7a6503b78613adc8bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">int</a> ltl::_expr_getalign </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the alignment (w.r.t. natural vector boundaries) of the operands in an expression. </p>
<p>When determining the alignment of an expression it is sufficient to return any one of the alignments from any one of the MArrays in the expression since we only vectorize if we know the alignments are the same. However, we must make sure that we do not ask e.g. a literal constant for a it's alignment ...</p>
<p>In the general case, just use the LHS's alignment ... We will provide partial specializations for the cases where one of the operands does not have an alignment and return the other's instead. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 11 2015 14:54:49 for LTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
