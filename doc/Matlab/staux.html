<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of staux</title>
  <meta name="keywords" content="staux">
  <meta name="description" content="StaMPS Auxulliary functions.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">Matlab</a> &gt; staux.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Matlab&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>staux
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>StaMPS Auxulliary functions.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function out = staux(fun, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> StaMPS Auxulliary functions.

 Based on codes by David Bekaert and Andrew Hooper from packages TRAIN
 (https://github.com/dbekaert/TRAIN) and
 StaMPS (https://homepages.see.leeds.ac.uk/~earahoo/stamps/).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>	fid = sfopen(path, mode, machine)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="traux.html" class="code" title="function out = metin(fun, varargin)">traux</a>	TRAIN Axilliary functions.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function h = boxplot_los(varargin)</a></li><li><a href="#_sub2" class="code">function [] = rel_std_filt(varargin)</a></li><li><a href="#_sub3" class="code">function [] = iterate_unwrapping(varargin)</a></li><li><a href="#_sub4" class="code">function [] = plot_loop(varargin)</a></li><li><a href="#_sub5" class="code">function out = binned_statistic(varargin)</a></li><li><a href="#_sub6" class="code">function out = binned_statistic_2d(varargin)</a></li><li><a href="#_sub7" class="code">function out = clap(varargin)</a></li><li><a href="#_sub8" class="code">function [] = plot_ph_grid(ph)</a></li><li><a href="#_sub9" class="code">function vv = load_ps_vel(plot_flags)</a></li><li><a href="#_sub10" class="code">function varargout = plot(varargin)</a></li><li><a href="#_sub11" class="code">function [] = report()</a></li><li><a href="#_sub12" class="code">function [] = ps_output()</a></li><li><a href="#_sub13" class="code">function [] = save_ascii(path, format, data)</a></li><li><a href="#_sub14" class="code">function h = plot_scatter(varargin)</a></li><li><a href="#_sub15" class="code">function [] = corr_phase(ifg, value)</a></li><li><a href="#_sub16" class="code">function [] = crop(varargin)</a></li><li><a href="#_sub17" class="code">function [] = crop_reset()</a></li><li><a href="#_sub18" class="code">function [] = save_llh()</a></li><li><a href="#_sub19" class="code">function [] = save_binary(varargin)</a></li><li><a href="#_sub20" class="code">function loaded = load_binary(varargin)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function out = staux(fun, varargin)</a>
0002 <span class="comment">% StaMPS Auxulliary functions.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Based on codes by David Bekaert and Andrew Hooper from packages TRAIN</span>
0005 <span class="comment">% (https://github.com/dbekaert/TRAIN) and</span>
0006 <span class="comment">% StaMPS (https://homepages.see.leeds.ac.uk/~earahoo/stamps/).</span>
0007 <span class="comment">%</span>
0008     
0009     <span class="keyword">switch</span>(fun)
0010         <span class="keyword">case</span> <span class="string">'save_llh'</span>
0011             <a href="#_sub18" class="code" title="subfunction [] = save_llh()">save_llh</a>();
0012         <span class="keyword">case</span> <span class="string">'save_binary'</span>
0013             <a href="#_sub19" class="code" title="subfunction [] = save_binary(varargin)">save_binary</a>(varargin{:});
0014         <span class="keyword">case</span> <span class="string">'load_binary'</span>
0015              out = <a href="#_sub20" class="code" title="subfunction loaded = load_binary(varargin)">load_binary</a>(varargin{:});
0016         <span class="keyword">case</span> <span class="string">'boxplot_los'</span>
0017              out = <a href="#_sub1" class="code" title="subfunction h = boxplot_los(varargin)">boxplot_los</a>(varargin{:});
0018         <span class="keyword">case</span> <span class="string">'binned_statistic'</span>
0019              out = <a href="#_sub5" class="code" title="subfunction out = binned_statistic(varargin)">binned_statistic</a>(varargin{:});
0020         <span class="keyword">case</span> <span class="string">'binned_statistic_2d'</span>
0021              out = <a href="#_sub6" class="code" title="subfunction out = binned_statistic_2d(varargin)">binned_statistic_2d</a>(varargin{:});
0022         <span class="keyword">case</span> <span class="string">'clap'</span>
0023              out = <a href="#_sub7" class="code" title="subfunction out = clap(varargin)">clap</a>(varargin{:});
0024         <span class="keyword">case</span> <span class="string">'iterate_unwrapping'</span>
0025              out = <a href="#_sub3" class="code" title="subfunction [] = iterate_unwrapping(varargin)">iterate_unwrapping</a>(varargin{:});
0026         <span class="keyword">case</span> <span class="string">'plot'</span>
0027              out = <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(varargin{:});
0028         <span class="keyword">case</span> <span class="string">'plot_scatter'</span>
0029              out = <a href="#_sub14" class="code" title="subfunction h = plot_scatter(varargin)">plot_scatter</a>(varargin{:});
0030         <span class="keyword">case</span> <span class="string">'plot_loop'</span>
0031              out = <a href="#_sub4" class="code" title="subfunction [] = plot_loop(varargin)">plot_loop</a>(varargin{:});
0032         <span class="keyword">case</span> <span class="string">'plot_ph_grid'</span>
0033              out = <a href="#_sub8" class="code" title="subfunction [] = plot_ph_grid(ph)">plot_ph_grid</a>(varargin{:});
0034         <span class="keyword">case</span> <span class="string">'ps_output'</span>
0035              <a href="#_sub12" class="code" title="subfunction [] = ps_output()">ps_output</a>();
0036         <span class="keyword">case</span> <span class="string">'rel_std_filt'</span>
0037              out = <a href="#_sub2" class="code" title="subfunction [] = rel_std_filt(varargin)">rel_std_filt</a>(varargin{:});
0038         <span class="keyword">case</span> <span class="string">'report'</span>
0039             <a href="#_sub11" class="code" title="subfunction [] = report()">report</a>();
0040         <span class="keyword">case</span> <span class="string">'crop'</span>
0041             <a href="#_sub16" class="code" title="subfunction [] = crop(varargin)">crop</a>(varargin);
0042         <span class="keyword">case</span> <span class="string">'crop_reset'</span>
0043             <a href="#_sub17" class="code" title="subfunction [] = crop_reset()">crop_reset</a>();
0044         <span class="keyword">otherwise</span>
0045             error([<span class="string">'Unknown function '</span>, fun]);
0046     <span class="keyword">end</span>
0047 <span class="keyword">end</span>
0048 
0049 <a name="_sub1" href="#_subfunctions" class="code">function h = boxplot_los(varargin)</a>
0050 doc = {
0051 <span class="string">''</span>
0052 <span class="string">'function h = BOXPLOT_LOS(plot_flags, out, ...)'</span>
0053 <span class="string">''</span>
0054 <span class="string">'The plot will be saved to an image file defined by the `out` argument. No '</span>
0055 <span class="string">'figure will pop up.'</span>
0056 <span class="string">'Plots the boxplot of LOS velocities defined by plot_flags.'</span>
0057 <span class="string">'Accepted plot flags are the same flags accepted by the ps_plot function,'</span>
0058 <span class="string">'with some extra rules.'</span>
0059 <span class="string">'    1) Multiple plot flags must be defined in a cell array, e.g.'</span>
0060 <span class="string">'    boxplot_los({''v-do'', ''v-da''});'</span>
0061 <span class="string">'    2) If we have the atmospheric correction option (''v-da''), the'</span>
0062 <span class="string">'    cooresponding atmospheric correction flag must be defined like this:'</span>
0063 <span class="string">'    ''v-da/a_e''. This denotes the DEM error and ERA-I corrected velocity'</span>
0064 <span class="string">'    values. Atmospheric coretcions can be calculated with TRAIN.'</span>
0065 <span class="string">''</span> 
0066 <span class="string">'  Additional options to the boxplot function can be passed using varargin.'</span>
0067 <span class="string">'  - ''fun'' : function to be applied to the velocity values; default value:'</span>
0068 <span class="string">'            nan (no function is applied); function should return a vector'</span>
0069 <span class="string">'            (in the case of a single plot flag) or a matrix'</span>
0070 <span class="string">'            (in the case of multiple plot flags).'</span>
0071 <span class="string">'  - ''boxplot_opt'': varargin arguments for boxplot, given in a cell array;'</span>
0072 <span class="string">'                  e.g.: ''boxplot_opt'', {''widths'', 0.5, ''whisker'', 2.0}'</span>
0073 <span class="string">'                  See the help of the boxplot function for additinal '</span>
0074 <span class="string">'                  information. Default value: nan (no options)'</span>
0075 <span class="string">''</span>
0076 <span class="string">'  The function returns the function handle `h` to the boxplot.'</span>
0077 <span class="string">''</span>
0078 };
0079 
0080     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0081         fprintf(<span class="string">'%s\n'</span>, doc{:});
0082         h = nan;
0083         <span class="keyword">return</span>;
0084     <span class="keyword">end</span>
0085 
0086     p = inputParser();
0087     
0088     p.FunctionName = <span class="string">'boxplot_los'</span>;
0089     p.addRequired(<span class="string">'plot_flags'</span>, @(x) ischar(x) | iscell(x));
0090     p.addRequired(<span class="string">'out'</span>, @(x) ischar(x));
0091     
0092     p.addParameter(<span class="string">'fun'</span>, @(x) x, @(x) isa(x, <span class="string">'function_handle'</span>));
0093     p.addParameter(<span class="string">'boxplot_opt'</span>, nan, @iscell);
0094     
0095     p.parse(varargin{:});
0096     args = p.Results;
0097     
0098     <span class="comment">% loading ps velocities</span>
0099     vv = <a href="#_sub9" class="code" title="subfunction vv = load_ps_vel(plot_flags)">load_ps_vel</a>(args.plot_flags);
0100     
0101     <span class="keyword">if</span> isa(args.fun, <span class="string">'function_handle'</span>)
0102         vv = args.fun(vv); <span class="comment">% apply the function</span>
0103     <span class="keyword">end</span>
0104 
0105     <span class="comment">% set up labels</span>
0106     <span class="keyword">if</span> iscell(args.boxplot_opt)
0107         n_var = length(args.boxplot_opt);
0108         
0109         <span class="comment">% labels are the velocity flags</span>
0110         args.boxplot_opt{n_var + 1} = <span class="string">'labels'</span>;
0111         args.boxplot_opt{n_var + 2} = args.plot_flags;
0112         
0113         boxopt = args.boxplot_opt;
0114     <span class="keyword">else</span>
0115         <span class="comment">% labels are the velocity flags</span>
0116         boxopt{1} = <span class="string">'labels'</span>;
0117         boxopt{2} = args.plot_flags;
0118     <span class="keyword">end</span>
0119     
0120     <span class="comment">% by default it will not show the figure</span>
0121     <span class="comment">% instead it will save it to an image file</span>
0122     h = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
0123     boxplot(vv, boxopt{:});
0124 
0125     ylabel(<span class="string">'LOS velocity [mm/yr]'</span>);
0126     saveas(h, args.out);
0127 <span class="keyword">end</span>
0128 
0129 <a name="_sub2" href="#_subfunctions" class="code">function [] = rel_std_filt(varargin)</a>
0130 doc = {
0131 <span class="string">''</span>
0132 <span class="string">'function REL_STD_FILT(max_rel_std)'</span>
0133 <span class="string">''</span>
0134 <span class="string">'Filters calculated LOS velocities based in their relative standard deviations.'</span>
0135 <span class="string">'Relative standard deviation = (standard deviation / mean) * 100 (conversion into %).'</span>
0136 <span class="string">''</span>
0137 <span class="string">'- max_rel_std       (input) maximum allowed realtive standard deviation'</span>
0138 <span class="string">''</span>
0139 <span class="string">'Filtered LOS velocities will be saved into &quot;ps_data_filt.xy&quot;, in ascii format.'</span>
0140 <span class="string">''</span>
0141 };
0142 
0143     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0144         fprintf(<span class="string">'%s\n'</span>, doc{:});
0145         <span class="keyword">return</span>;
0146     <span class="keyword">end</span>
0147     
0148     <span class="comment">% parse input arguments</span>
0149     p = inputParser();
0150     p.FunctionName = <span class="string">'rel_std_filt'</span>;
0151     p.addRequired(<span class="string">'max_rel_std'</span>, @isscalar);
0152 
0153     p.parse(varargin{:});
0154     args = p.Results;
0155     
0156     <span class="comment">% create ps_data.xy if it does not exist</span>
0157     <span class="keyword">if</span> ~exist(<span class="string">'ps_data.xy'</span>, <span class="string">'file'</span>)
0158         <a href="#_sub12" class="code" title="subfunction [] = ps_output()">ps_output</a>;
0159     <span class="keyword">end</span>
0160     
0161     <span class="keyword">if</span> ~exist(<span class="string">'ps_mean_v_std.xy'</span>, <span class="string">'file'</span>)
0162         ps_mean_v;
0163     <span class="keyword">end</span>
0164     
0165     ps_std = load(<span class="string">'ps_mean_v_std.xy'</span>, <span class="string">'-ascii'</span>);
0166     ps_data = load(<span class="string">'ps_data.xy'</span>, <span class="string">'-ascii'</span>);
0167     
0168     rel_std = ps_data(:,3) ./ ps_std(:,3) * 100;
0169     
0170     idx = rel_std &lt; args.max_rel_std;
0171     
0172     before = size(ps_data, 1);
0173     after = sum(idx);
0174     
0175     ps_data = ps_data(idx,:);
0176     
0177     fprintf([<span class="string">'Number of points before filtering: %d\n'</span>, <span class="keyword">...</span>
0178              <span class="string">'Number of points after filtering: %d\n'</span>], before, after);
0179     
0180     save(<span class="string">'ps_data_filt.xy'</span>, <span class="string">'ps_data'</span>, <span class="string">'-ascii'</span>);
0181 <span class="keyword">end</span>
0182 
0183 <a name="_sub3" href="#_subfunctions" class="code">function [] = iterate_unwrapping(varargin)</a>
0184 doc = {
0185 <span class="string">''</span>
0186 <span class="string">'function ITERATE_UNWRAPPING(numiter)'</span>
0187 <span class="string">''</span>
0188 <span class="string">'Simply iterate the unwrapping process _numiter_ times.'</span>
0189 <span class="string">'At every iteration the spatially-correlated look angle error is calculated '</span>
0190 <span class="string">'(StaMPS Step 7) can be calculated.'</span>
0191 <span class="string">''</span>
0192 <span class="string">'At the start of the iteration and at every iteration step the phase residuals '</span>
0193 <span class="string">'will be plotted into a png file, named iteration_(ii).png'</span>
0194 <span class="string">'where ii is the iteration step.'</span>
0195 <span class="string">''</span>
0196 <span class="string">'- numiter:       (input) number of iteraions'</span>
0197 <span class="string">'- ''scla'', false: (optional) by default SCLA corrections will NOT be calculated'</span>
0198 <span class="string">''</span>
0199 };
0200 
0201     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0202         fprintf(<span class="string">'%s\n'</span>, doc{:});
0203         <span class="keyword">return</span>;
0204     <span class="keyword">end</span>
0205 
0206     p = inputParser();
0207     p.FunctionName = <span class="string">'iterate_unwrapping'</span>;
0208     p.addRequired(<span class="string">'numiter'</span>, @isscalar);
0209     p.addParameter(<span class="string">'scla'</span>, false, @(x) isa(x, <span class="string">'logical'</span>));
0210 
0211     p.parse(varargin{:});
0212     args = p.Results;
0213     
0214     <span class="keyword">if</span> args.scla
0215         end_step = 7;
0216     <span class="keyword">else</span>
0217         end_step = 6;
0218     <span class="keyword">end</span>
0219     
0220     <span class="comment">% remove previous pngs</span>
0221     delete iteration_*.png;
0222 
0223     h = figure; set(h, <span class="string">'Visible'</span>, <span class="string">'off'</span>);
0224 
0225     <span class="comment">% plot starting residuals</span>
0226     h = ps_plot(<span class="string">'rsb'</span>);
0227     print(<span class="string">'-dpng'</span>, <span class="string">'-r300'</span>, sprintf(<span class="string">'iteration_%d.png'</span>, 0));
0228     close(h);
0229     
0230     <span class="keyword">for</span> ii = 1:args.numiter
0231         fprintf(<span class="string">'################\n'</span>);
0232         fprintf(<span class="string">'ITERATION #%d\n'</span>, ii);
0233         fprintf(<span class="string">'################\n'</span>);
0234         stamps(6,end_step);
0235         h = figure; set(h, <span class="string">'Visible'</span>, <span class="string">'off'</span>);
0236         h = ps_plot(<span class="string">'rsb'</span>);
0237         print(<span class="string">'-dpng'</span>, <span class="string">'-r300'</span>, sprintf(<span class="string">'iteration_%d.png'</span>, ii));
0238         close(h);
0239     <span class="keyword">end</span>
0240 <span class="keyword">end</span>
0241 
0242 <a name="_sub4" href="#_subfunctions" class="code">function [] = plot_loop(varargin)</a>
0243 doc = {
0244 <span class="string">'function plot_loop(loop)'</span>
0245 <span class="string">''</span>
0246 <span class="string">'Plots residual phase terms (''rsb'') for the selected'</span>
0247 <span class="string">'interferograms.'</span>
0248 <span class="string">''</span>
0249 <span class="string">'- loop: (input) vector of interferogram indices'</span>
0250 <span class="string">''</span>
0251 <span class="string">'E.g.: plot_loop([1 2 3]); will plot ''rsb'' values for '</span>
0252 <span class="string">'IFG 1, 2 and 3.'</span>
0253 };
0254 
0255     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0256         fprintf(<span class="string">'%s\n'</span>, doc{:});
0257         <span class="keyword">return</span>;
0258     <span class="keyword">end</span>
0259 
0260     p = inputParser();
0261     p.FunctionName = <span class="string">'plot_loop'</span>;
0262     p.addRequired(<span class="string">'loop'</span>, @isvector);
0263 
0264     p.parse(varargin{:});
0265     args = p.Results;
0266 
0267     ps_plot(<span class="string">'rsb'</span>, 1, 0, 0, args.loop);
0268 <span class="keyword">end</span>
0269 
0270 <a name="_sub5" href="#_subfunctions" class="code">function out = binned_statistic(varargin)</a>
0271 doc = {
0272 <span class="string">'binned = binned_statistic(x, y, ...)'</span>
0273 <span class="string">''</span>
0274 <span class="string">'Sorts y values into bins defined along x values.'</span>
0275 <span class="string">'By default sums y values in each of the x bins.'</span>
0276 <span class="string">''</span>
0277 <span class="string">'- x and y: (input) x and y value pairs, should be'</span>
0278 <span class="string">'a vector with the same number of elements'</span>
0279 <span class="string">''</span>
0280 <span class="string">'- ''bins'': (input, optional) number of bins or bin'</span>
0281 <span class="string">'edges defined by a vector (default: 10)'</span>
0282 <span class="string">''</span>
0283 <span class="string">'- ''fun'': (input, optional) function to apply to'</span>
0284 <span class="string">'y values in each bin. By default this is a summation'</span>
0285 <span class="string">''</span>
0286 <span class="string">'E.g. y_binned = binned_statistic(x, y, ''bins'', 100, ...'</span>
0287 <span class="string">'                                 ''fun'', @mean)'</span>
0288 <span class="string">'This will bin y values into x bins and calculate their'</span>
0289 <span class="string">'mean in each x bins. 100 bins will be placed evenly along'</span>
0290 <span class="string">'the values of x.'</span>
0291 };
0292 
0293     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0294         fprintf(<span class="string">'%s\n'</span>, doc{:});
0295         out = nan;
0296         <span class="keyword">return</span>;
0297     <span class="keyword">end</span>
0298     
0299     p = inputParser();
0300     
0301     p.addRequired(<span class="string">'x'</span>, @isvector);
0302     p.addRequired(<span class="string">'y'</span>, @isvector);
0303     
0304     <span class="comment">% 10 bins by default</span>
0305     p.addParameter(<span class="string">'bins'</span>, 10, @(x) isvector(x) || isscalar(x));
0306     
0307     <span class="comment">% default behaviour is summing y values in x bins</span>
0308     p.addParameter(<span class="string">'fun'</span>, nan, @(x) isnan(x) || <span class="keyword">...</span>
0309                                       isa(x, <span class="string">'function_handle'</span>));
0310     
0311     p.parse(varargin{:});
0312     args = p.Results;
0313     
0314     x = args.x;
0315     y = args.y;
0316     fun = args.fun;
0317     bins = args.bins;
0318     
0319     <span class="keyword">if</span> isscalar(bins)
0320         bins = linspace(min(x), max(x), bins);
0321     <span class="keyword">end</span>
0322     
0323     <span class="comment">% calculate indices that place y values into</span>
0324     <span class="comment">% their respective x bins</span>
0325     [~, idx] = histc(x, bins);
0326     
0327     <span class="comment">% do not select values that are out of the range</span>
0328     <span class="comment">% of x bins</span>
0329     y = y(idx &gt; 0.0);
0330     idx = idx(idx &gt; 0.0);
0331     
0332     <span class="keyword">if</span> isnan(fun)
0333         binned = accumarray(idx', y', []);
0334     <span class="keyword">else</span>
0335         binned = accumarray(idx', y', [], fun);
0336     <span class="keyword">end</span>
0337     out.binned = binned;
0338     out.bins = bins;
0339 <span class="keyword">end</span>
0340 
0341 <a name="_sub6" href="#_subfunctions" class="code">function out = binned_statistic_2d(varargin)</a>
0342 doc = {
0343 <span class="string">'binned = binned_statistic_2d(x, y, z, ...)'</span>
0344 <span class="string">''</span>
0345 <span class="string">'Sorts z values into bins defined along (x,y) values.'</span>
0346 <span class="string">'By default sums z values in each of the (x,y) bins.'</span>
0347 <span class="string">''</span>
0348 <span class="string">'- x, y and z: (input) x, y and z value triplets, should be'</span>
0349 <span class="string">'vectors with the same number of elements'</span>
0350 <span class="string">''</span>
0351 <span class="string">'- ''xbins'': (input, optional) number of bins or bin'</span>
0352 <span class="string">'edges defined by a vector along x (default: 10)'</span>
0353 <span class="string">''</span>
0354 <span class="string">'- ''ybins'': (input, optional) number of bins or bin'</span>
0355 <span class="string">'edges defined by a vector along y (default: 10)'</span>
0356 <span class="string">''</span>
0357 <span class="string">'- ''fun'': (input, optional) function to apply to'</span>
0358 <span class="string">'z values in each bin. By default this is a summation.'</span>
0359 <span class="string">''</span>
0360 <span class="string">'E.g. z_binned = binned_statistic(x, y, z, ''xbins'', 100, ...'</span>
0361 <span class="string">'                                 ''fun'', @mean)'</span>
0362 <span class="string">'This will bin z values into (x,y) bins and calculate their'</span>
0363 <span class="string">'mean in each (x,y) bins. 100 bins will be placed evenly along'</span>
0364 <span class="string">'the values of x and 10 bins along the values of y.'</span>
0365 };
0366  
0367     <span class="keyword">if</span> strcmp(varargin{1}, <span class="string">'help'</span>)
0368         fprintf(<span class="string">'%s\n'</span>, doc{:});
0369         out = nan;
0370         <span class="keyword">return</span>;
0371     <span class="keyword">end</span>
0372     
0373     p = inputParser();
0374     
0375     p.addRequired(<span class="string">'x'</span>, @isvector);
0376     p.addRequired(<span class="string">'y'</span>, @isvector);
0377     p.addRequired(<span class="string">'z'</span>, @isvector);
0378     
0379     <span class="comment">% 10 bins by default</span>
0380     p.addParameter(<span class="string">'xbins'</span>, 10, @(x) isvector(x) || isscalar(x));
0381     p.addParameter(<span class="string">'ybins'</span>, 10, @(x) isvector(x) || isscalar(x));
0382     
0383     <span class="comment">% default behaviour is summing z values in (x,y) bins</span>
0384     p.addParameter(<span class="string">'fun'</span>, <span class="string">'sum'</span>, @(x) ischar(x) || <span class="keyword">...</span>
0385                                       isa(x, <span class="string">'function_handle'</span>));
0386     
0387     p.parse(varargin{:});
0388 
0389     x = p.Results.x;
0390     y = p.Results.y;
0391     z = p.Results.z;
0392     fun = p.Results.fun;
0393     xbins = p.Results.xbins;
0394     ybins = p.Results.ybins;
0395 
0396     <span class="keyword">if</span> isscalar(xbins)
0397         xbins = linspace(min(x), max(x), xbins);
0398     <span class="keyword">end</span>
0399 
0400     <span class="keyword">if</span> isscalar(ybins)
0401         ybins = linspace(min(y), max(y), ybins);
0402     <span class="keyword">end</span>
0403 
0404 
0405     <span class="comment">% calculate indices that place (x,y) values into</span>
0406     <span class="comment">% their respective (x,y) bins</span>
0407     [~, idx_x] = histc(x, xbins);
0408     [~, idx_y] = histc(y, ybins);
0409 
0410     <span class="comment">% do not select values that are out of the range</span>
0411     <span class="comment">% of (x,y) bins</span>
0412     idx = idx_x &gt; 0.0 &amp; idx_y &gt; 0.0;
0413     
0414     z = z(idx);
0415     idx_x = idx_x(idx);
0416     idx_y = idx_y(idx);
0417 
0418     <span class="keyword">if</span> strcmp(fun, <span class="string">'sum'</span>)
0419         binned = accumarray([idx_x, idx_y], z, []);
0420     <span class="keyword">else</span>
0421         binned = accumarray([idx_x, idx_y], z, [], fun);
0422     <span class="keyword">end</span>
0423     out.binned = binned;
0424     out.xbins = xbins;
0425     out.ybins = ybins;
0426 <span class="keyword">end</span>
0427 
0428 <a name="_sub7" href="#_subfunctions" class="code">function out = clap(varargin)</a>
0429 <span class="comment">% Based on the Combined Low-pass Adaptive Filter of the StaMPS package</span>
0430 <span class="comment">% developed by Andrew Hooper.</span>
0431 <span class="comment">% Modified CLAP filter. I used it to play around with the filter</span>
0432 <span class="comment">% parameters. Feel free to ingore it.</span>
0433     
0434     p = inputParser();
0435     
0436     p.addParameter(<span class="string">'grid_size'</span>, 50, @isscalar)
0437     p.addParameter(<span class="string">'alpha'</span>, 1, @isscalar)
0438     p.addParameter(<span class="string">'beta'</span>, 0.3, @isscalar)
0439     p.addParameter(<span class="string">'low_pass'</span>, 800, @isscalar)
0440     p.addParameter(<span class="string">'win_size'</span>, 32, @isscalar)
0441     p.addParameter(<span class="string">'ifg_list'</span>, [], @(x) isscalar(x))
0442     
0443     p.parse(varargin{:});
0444     
0445     grid_size = p.Results.grid_size;
0446     clap_alpha = p.Results.alpha;
0447     clap_beta = p.Results.beta;
0448     low_pass_wavelength = p.Results.low_pass;
0449     n_win = p.Results.win_size;
0450     ifg_idx = p.Results.ifg_list;
0451     
0452     freq0 = 1 / low_pass_wavelength;
0453     freq_i= -n_win / grid_size / n_win / 2:1 / grid_size / n_win:(n_win-2) / <span class="keyword">...</span>
0454              grid_size / n_win / 2;
0455     butter_i = 1 ./ (1 + (freq_i / freq0).^(2*5));
0456     low_pass = butter_i' * butter_i;
0457     low_pass = fftshift(low_pass);
0458 
0459     ps=load(<span class="string">'ps1.mat'</span>);
0460     bp=load(<span class="string">'bp1.mat'</span>);
0461 
0462     phin=load(<span class="string">'ph1.mat'</span>);
0463     ph=phin.ph;
0464     clear phin
0465 
0466     <span class="keyword">if</span> isempty(ifg_idx)
0467         n_ifg = ps.n_ifg;
0468         ifg_idx = 1:n_ifg;
0469     <span class="keyword">elseif</span> isvector(ifg_idx)
0470         n_ifg = length(ifg_idx);
0471     <span class="keyword">else</span>
0472         n_ifg = 1;
0473         ifg_idx = [ifg_idx];
0474     <span class="keyword">end</span>
0475             
0476     bperp = ps.bperp(ifg_idx);
0477     n_image = ps.n_image;
0478     n_ps = ps.n_ps;
0479     ifgday_ix = ps.ifgday_ix(ifg_idx,:);
0480     xy = ps.xy;
0481 
0482     K_ps = zeros(n_ps,1);
0483     
0484     clear ps
0485 
0486     xbins = min(xy(:,2)):grid_size:max(xy(:,2));
0487     ybins = min(xy(:,3)):grid_size:max(xy(:,3));
0488 
0489     n_i = length(xbins);
0490     n_j = length(ybins);
0491     ph_grid = zeros(n_i, n_j, <span class="string">'single'</span>);
0492     ph_filt = zeros(n_j, n_i, <span class="string">'single'</span>);
0493 
0494     
0495     da = load(<span class="string">'da1.mat'</span>);
0496     D_A = da.D_A;
0497     clear da
0498 
0499     weighting = 1 ./ D_A;
0500 
0501     ph_weight = ph(:,ifg_idx).*exp(-j * bp.bperp_mat(:,ifg_idx).* <span class="keyword">...</span>
0502                 repmat(K_ps, 1, n_ifg)) .* repmat(weighting, 1, n_ifg);
0503     
0504     <span class="keyword">if</span> n_ifg == 1
0505         ph_grid = <a href="#_sub6" class="code" title="subfunction out = binned_statistic_2d(varargin)">binned_statistic_2d</a>(xy(:,2), xy(:,3), ph_weight, <span class="keyword">...</span>
0506                           <span class="string">'xbins'</span>, xbins, <span class="string">'ybins'</span>, ybins);
0507         ph_filt = clap_filt(transpose(ph_grid), clap_alpha, clap_beta, <span class="keyword">...</span>
0508                                    n_win * 0.75, n_win * 0.25, low_pass);
0509     <span class="keyword">else</span>            
0510         <span class="keyword">for</span> ii = ifg_idx
0511             ph_grid = <a href="#_sub6" class="code" title="subfunction out = binned_statistic_2d(varargin)">binned_statistic_2d</a>(xy(:,2), xy(:,3), ph_weight(:,ii), <span class="keyword">...</span>
0512                               <span class="string">'xbins'</span>, xbins, <span class="string">'ybins'</span>, ybins);
0513             ph_filt = clap_filt(transpose(ph_grid), clap_alpha, clap_beta, <span class="keyword">...</span>
0514                                        n_win * 0.75, n_win * 0.25, low_pass);
0515         <span class="keyword">end</span>
0516     <span class="keyword">end</span>
0517     out.ph_filt = ph_filt;
0518     out.ph_grid = ph_grid;
0519 <span class="keyword">end</span>
0520 
0521 
0522 <a name="_sub8" href="#_subfunctions" class="code">function [] = plot_ph_grid(ph)</a>
0523 <span class="comment">% Auxilliary function for plotting the output of the modified CLAP filter</span>
0524     figure();
0525     colormap(<span class="string">'jet'</span>);
0526     imagesc(angle(ph));
0527     colorbar();
0528 <span class="keyword">end</span>
0529 
0530 <a name="_sub9" href="#_subfunctions" class="code">function vv = load_ps_vel(plot_flags)</a>
0531 <span class="comment">% Helper function that loads LOS velocities defined by plot_flags.</span>
0532 <span class="comment">%</span>
0533 
0534     <span class="comment">% if we have multiple plot_flags</span>
0535     <span class="keyword">if</span> iscell(plot_flags)
0536         
0537         n_flags = length(plot_flags);
0538 
0539         ps = load(<span class="string">'ps2.mat'</span>);
0540         
0541         <span class="comment">% allocating space for velocity values</span>
0542         vv = zeros(size(ps.lonlat, 1), n_flags);
0543         
0544         clear ps;
0545         
0546         <span class="keyword">for</span> ii = 1:n_flags <span class="comment">% going through flags</span>
0547             
0548             <span class="comment">% splitting for atmospheric flags</span>
0549             plot_flag = strsplit(plot_flags{ii}, <span class="string">'/'</span>);
0550             
0551             <span class="comment">% write velocities into a mat file and load it</span>
0552             
0553             <span class="comment">% if we have atmospheric flag</span>
0554             <span class="keyword">if</span> length(plot_flag) &gt; 1
0555                 ps_plot(plot_flag{1}, plot_flag{2}, -1);
0556                 v = load(sprintf(<span class="string">'ps_plot_%s'</span>, lower(plot_flag{1})));
0557             <span class="keyword">else</span>
0558                 ps_plot(plot_flag{1}, -1);
0559                 v = load(sprintf(<span class="string">'ps_plot_%s'</span>, lower(plot_flag{1})));
0560             <span class="keyword">end</span>
0561     
0562             <span class="comment">% put velocity values into the corresponding column</span>
0563             vv(:,ii) = v.ph_disp;
0564         <span class="keyword">end</span> <span class="comment">% end for</span>
0565     <span class="keyword">else</span>
0566         <span class="comment">% splitting for atmospheric flags</span>
0567         plot_flag = strsplit(plot_flags, <span class="string">'/'</span>);
0568         
0569         <span class="comment">% write velocities into a mat file and load it</span>
0570         <span class="keyword">if</span> length(plot_flag) &gt; 1 <span class="comment">% if we have atmospheric flag</span>
0571             ps_plot(plot_flag{1}, plot_flag{2}, -1);
0572             v = load(sprintf(<span class="string">'ps_plot_%s'</span>, lower(plot_flag{1})));
0573         <span class="keyword">else</span>
0574             ps_plot(plot_flag{1}, -1);
0575             v = load(sprintf(<span class="string">'ps_plot_%s'</span>, lower(plot_flag{1})));
0576         <span class="keyword">end</span>
0577         vv = v.ph_disp;
0578     <span class="keyword">end</span>
0579 <span class="keyword">end</span>
0580 
0581 <a name="_sub10" href="#_subfunctions" class="code">function varargout = plot(varargin)</a>
0582 <span class="comment">% Wrapper function for ps_plot with argument handling that is more user friendly</span>
0583 <span class="comment">%</span>
0584     p = inputParser();
0585     
0586     p.FunctionName = <span class="string">'plot'</span>;
0587     
0588     p.addRequired(<span class="string">'value_type'</span>, @ischar);
0589     p.addRequired(<span class="string">'out'</span>, @ischar);
0590     
0591     p.addParameter(<span class="string">'background'</span>, 1, @isscalar);    
0592     p.addParameter(<span class="string">'phase_lims'</span>, 0, @(x) isvector(x) || isscalar(x));
0593     p.addParameter(<span class="string">'ref_ifg'</span>, 0, @isscalar);
0594     p.addParameter(<span class="string">'ifg_list'</span>, [], @isvector);
0595     p.addParameter(<span class="string">'n_x'</span>, 0, @isscalar);
0596     p.addParameter(<span class="string">'cbar_flag'</span>, 0, @(x) x == 1 || x == 2 || x == 0);
0597     p.addParameter(<span class="string">'textsize'</span>, 0, @isscalar);
0598     p.addParameter(<span class="string">'textcolor'</span>, [], @isvector);
0599     p.addParameter(<span class="string">'lon_rg'</span>, [], @isvector);
0600     p.addParameter(<span class="string">'lat_rg'</span>, [], @isvector);
0601     
0602     p.parse(varargin{:});
0603     
0604     args = p.Results;
0605     
0606     value_type = strsplit(args.value_type, <span class="string">'/'</span>);
0607     
0608     <span class="keyword">if</span> length(value_type) == 1
0609         h = ps_plot(value_type{1}, args.background, args.phase_lims, args.ref_ifg, <span class="keyword">...</span>
0610                     args.ifg_list, args.n_x, args.cbar_flag, args.textsize, <span class="keyword">...</span>
0611                     args.textcolor, args.lon_rg, args.lat_rg);
0612     <span class="keyword">elseif</span> length(value_type) == 2
0613         h = ps_plot(value_type{1}, value_type{2}, args.background, args.phase_lims, <span class="keyword">...</span>
0614                     args.ref_ifg, args.ifg_list, args.n_x, args.cbar_flag, <span class="keyword">...</span>
0615                     args.textsize, args.textcolor, args.lon_rg, args.lat_rg);
0616     <span class="keyword">else</span>
0617         error(<span class="string">''</span>);
0618     <span class="keyword">end</span>
0619     
0620     saveas(h, args.out)
0621     varargout = h;
0622 <span class="keyword">end</span>
0623 
0624 <a name="_sub11" href="#_subfunctions" class="code">function [] = report()</a>
0625 <span class="comment">% Just a bunch of plots</span>
0626 <span class="comment">%</span>
0627     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'w'</span>, <span class="string">'wrapped.png'</span>);
0628     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'u'</span>, <span class="string">'unwrapped.png'</span>);
0629     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'u-do'</span>, <span class="string">'unwrapped_do.png'</span>);
0630     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'usb'</span>, <span class="string">'unwrapped_sb.png'</span>);
0631     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'rsb'</span>, <span class="string">'rsb.png'</span>);
0632     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'usb-do'</span>, <span class="string">'unwrapped_sb_do.png'</span>);
0633     
0634     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'V'</span>, <span class="string">'vel.png'</span>);
0635     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'Vs'</span>, <span class="string">'vel_std.png'</span>);
0636     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'V-do'</span>, <span class="string">'vel_do.png'</span>);
0637     <a href="#_sub10" class="code" title="subfunction varargout = plot(varargin)">plot</a>(<span class="string">'Vs-do'</span>, <span class="string">'vel_std_do.png'</span>);
0638     
0639 <span class="keyword">end</span>
0640 
0641 <a name="_sub12" href="#_subfunctions" class="code">function [] = ps_output()</a>
0642 <span class="comment">% MODIFIED ps_output from StaMPS. For some reason save('data.txt', 'data', '-ascii')</span>
0643 <span class="comment">% did not work for me. I made some simple modifications to make it work</span>
0644 <span class="comment">% with my `save_ascii` function (see the next function in this library).</span>
0645 
0646     <span class="comment">%PS_OUTPUT write various output files</span>
0647     <span class="comment">%</span>
0648     <span class="comment">%   Andy Hooper, June 2006</span>
0649     <span class="comment">%</span>
0650     <span class="comment">%   =======================================================================</span>
0651     <span class="comment">%   09/2009 AH: Correct processing for small baselines output</span>
0652     <span class="comment">%   03/2010 AH: Add velocity standard deviation</span>
0653     <span class="comment">%   09/2011 AH: Remove code that reduces extreme values</span>
0654     <span class="comment">%   02/2015 AH: Remove code that reduces the extreme values in u-dm</span>
0655     <span class="comment">%   =======================================================================</span>
0656     
0657     fprintf(<span class="string">'Writing output files...\n'</span>)
0658     
0659     small_baseline_flag = getparm(<span class="string">'small_baseline_flag'</span>,1);
0660     ref_vel = getparm(<span class="string">'ref_velocity'</span>,1);
0661     lambda = getparm(<span class="string">'lambda'</span>,1);
0662     
0663     load psver
0664     psname=[<span class="string">'ps'</span>, num2str(psver)];
0665     rcname=[<span class="string">'rc'</span>, num2str(psver)];
0666     phuwname=[<span class="string">'phuw'</span>, num2str(psver)];
0667     sclaname=[<span class="string">'scla'</span>, num2str(psver)];
0668     hgtname=[<span class="string">'hgt'</span>, num2str(psver)];
0669     scnname=[<span class="string">'scn'</span>, num2str(psver)];
0670     mvname=[<span class="string">'mv'</span>, num2str(psver)];
0671     meanvname=[<span class="string">'mean_v'</span>];
0672     
0673     ps=load(psname);
0674     phuw=load(phuwname);
0675     rc=load(rcname);
0676     
0677     <span class="keyword">if</span> strcmpi(small_baseline_flag,<span class="string">'y'</span>)
0678         n_image=ps.n_image;
0679     <span class="keyword">else</span>
0680         n_image=ps.n_ifg;
0681     <span class="keyword">end</span>
0682     
0683     <span class="comment">%ijname=['ps_ij.txt'];</span>
0684     ij=ps.ij(:,2:3);
0685     <span class="comment">% save(ijname,'ij','-ASCII');</span>
0686     <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(<span class="string">'ps_ij.txt'</span>, <span class="string">'%d %d\n'</span>, ij)
0687     
0688     
0689     <span class="comment">%llname=['ps_ll.txt'];</span>
0690     lonlat=ps.lonlat;
0691     <span class="comment">% save(llname,'lonlat','-ASCII');</span>
0692     <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(<span class="string">'ps_ll.txt'</span>, <span class="string">'%f %f\n'</span>, lonlat);
0693     
0694     
0695     <span class="comment">%datename=['date.txt'];</span>
0696     date_out=str2num(datestr(ps.day, <span class="string">'yyyymmdd'</span>));
0697     <span class="comment">% save(datename,'date_out','-ascii','-double');</span>
0698     <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(<span class="string">'date.txt'</span>, <span class="string">'%f\n'</span>, date_out);
0699     
0700     master_ix = sum(ps.master_day&gt;ps.day) + 1;
0701     
0702     ref_ps = ps_setref;
0703     ph_uw = phuw.ph_uw - repmat(mean(phuw.ph_uw(ref_ps,:)), ps.n_ps,1);
0704     ph_w = angle(rc.ph_rc.*repmat(conj(sum(rc.ph_rc(ref_ps,:))), ps.n_ps,1));
0705     ph_w(:,master_ix) = 0;
0706     
0707     
0708     fid = fopen(<span class="string">'ph_w.flt'</span>, <span class="string">'w'</span>);
0709     fwrite(fid, ph_w', <span class="string">'float'</span>);
0710     fclose(fid);
0711     
0712     fid = fopen(<span class="string">'ph_uw.flt'</span>, <span class="string">'w'</span>);
0713     fwrite(fid,ph_uw', <span class="string">'float'</span>);
0714     fclose(fid);
0715     
0716     scla = load(sclaname);
0717 
0718     <span class="keyword">if</span> exist([hgtname, <span class="string">'.mat'</span>],<span class="string">'file'</span>)
0719         hgt = load(hgtname);
0720     <span class="keyword">else</span>
0721         hgt.hgt = zeros(ps.n_ps,1);
0722     <span class="keyword">end</span>
0723     
0724     ph_uw = phuw.ph_uw - scla.ph_scla - repmat(scla.C_ps_uw,1,n_image);
0725     
0726     <span class="comment">%%% this is only approximate</span>
0727     K_ps_uw = scla.K_ps_uw-mean(scla.K_ps_uw);
0728     dem_error = double(K2q(K_ps_uw, ps.ij(:,3)));
0729     
0730     hgt_idx = hgt.hgt == 0;
0731     
0732     <span class="keyword">if</span> sum(hgt_idx)
0733         dem_error = dem_error - mean(dem_error(hgt_idx));
0734     <span class="keyword">end</span>
0735     
0736     <span class="comment">%dem_error=dem_error-mean(dem_error(hgt.hgt==0));</span>
0737     dem_sort = sort(dem_error);
0738     min_dem = dem_sort(ceil(length(dem_sort)*0.001));
0739     max_dem = dem_sort(floor(length(dem_sort)*0.999));
0740     dem_error_tt = dem_error;
0741     dem_error_tt(dem_error &lt; min_dem) = min_dem; <span class="comment">% for plotting purposes</span>
0742     dem_error_tt(dem_error&gt;max_dem) = max_dem; <span class="comment">% for plotting purposes</span>
0743     dem_error_tt = [ps.lonlat, dem_error_tt];
0744     
0745     <span class="comment">% save('dem_error.xy','dem_error_tt','-ascii');</span>
0746     <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(<span class="string">'dem_error.xy'</span>, <span class="string">'%f %f %f\n'</span>, dem_error_tt);
0747     
0748     <span class="comment">%%%</span>
0749     
0750     clear scla phuw
0751     ph_uw = ph_uw - repmat(mean(ph_uw(ref_ps,:)), ps.n_ps,1);
0752     
0753     meanv = load(meanvname);
0754     <span class="comment">% m(1,:) is master APS + mean deviation from model</span>
0755     mean_v = - meanv.m(2,:)' * 365.25 / 4 / pi * lambda * 1000 + ref_vel * 1000;
0756     
0757     <span class="comment">%v_sort=sort(mean_v);</span>
0758     <span class="comment">%min_v=v_sort(ceil(length(v_sort)*0.001));</span>
0759     <span class="comment">%max_v=v_sort(floor(length(v_sort)*0.999));</span>
0760     <span class="comment">%mean_v(mean_v&lt;min_v)=min_v;</span>
0761     <span class="comment">%mean_v(mean_v&gt;max_v)=max_v;</span>
0762     
0763     
0764     <span class="comment">%mean_v_name = ['ps_mean_v.xy'];</span>
0765     mean_v = [ps.lonlat,double(mean_v)];
0766     <span class="comment">%save(mean_v_name,'mean_v','-ascii');</span>
0767     <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(<span class="string">'ps_mean_v.xy'</span>, <span class="string">'%f %f %f\n'</span>, mean_v);
0768     
0769     
0770     <span class="keyword">if</span> exist([<span class="string">'./'</span>,mvname,<span class="string">'.mat'</span>], <span class="string">'file'</span>);
0771         mv = load(mvname);
0772         mean_v_std = mv.mean_v_std;
0773         v_sort = sort(mean_v_std);
0774         min_v = v_sort(ceil(length(v_sort)*0.001));
0775         max_v = v_sort(floor(length(v_sort)*0.999));
0776         mean_v_std(mean_v_std &lt; min_v) = min_v;
0777         mean_v_std(mean_v_std &gt; max_v) = max_v;
0778         mean_v_name = [<span class="string">'ps_mean_v_std.xy'</span>];
0779         mean_v = [ps.lonlat,double(mean_v_std)];
0780         <span class="comment">%save(mean_v_name,'mean_v','-ascii');</span>
0781         <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>(mean_v_name, <span class="string">'%f %f %f\n'</span>, mean_v);
0782     <span class="keyword">end</span>
0783     
0784     
0785     <span class="comment">%%Note mean_v is relative to a reference point</span>
0786     <span class="comment">%%and dem_error is relative to mean of zero height points (if there are any)</span>
0787     fid=fopen(<span class="string">'ps_data.xy'</span>,<span class="string">'w'</span>);
0788     fprintf(fid,<span class="string">'%f %f %4.4f %4.4f %4.4f\n'</span>,[mean_v,double(hgt.hgt),dem_error]');
0789     fclose(fid)
0790     
0791     <span class="keyword">for</span> i=1:n_image
0792         ph=ph_uw(:,i);
0793 
0794         ph=-ph*lambda*1000/4/pi;
0795         ph=[ps.lonlat,double(ph)];
0796         <span class="comment">%save(['ps_u-dm.',num2str(i),'.xy'],'ph','-ascii');</span>
0797         <a href="#_sub13" class="code" title="subfunction [] = save_ascii(path, format, data)">save_ascii</a>([<span class="string">'ps_u-dm.'</span>,num2str(i),<span class="string">'.xy'</span>], <span class="string">'%f %f %f\n'</span>, ph);
0798     <span class="keyword">end</span>
0799 
0800 <span class="keyword">end</span>
0801 
0802 <a name="_sub13" href="#_subfunctions" class="code">function [] = save_ascii(path, format, data)</a>
0803 <span class="comment">% Replacement for save(path, 'data', '-ascii')</span>
0804 
0805     [FID, msg] = fopen(path, <span class="string">'w'</span>);
0806     
0807     <span class="keyword">if</span> FID == -1
0808         error([<span class="string">'Could not open file: '</span>, path, <span class="string">'\nError message: '</span>, msg]);
0809     <span class="keyword">end</span>
0810 
0811     fprintf(FID, format, data');
0812     fclose(FID);
0813     
0814 <span class="keyword">end</span>
0815 
0816 <a name="_sub14" href="#_subfunctions" class="code">function h = plot_scatter(varargin)</a>
0817 
0818     check_matrix = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0819                                 {<span class="string">'nonempty'</span>, <span class="string">'finite'</span>, <span class="string">'ndims'</span>, 2});
0820     
0821     p = inputParser;
0822     p.FunctionName = <span class="string">'plot_scatter'</span>;
0823     p.addRequired(<span class="string">'data'</span>, check_matrix);
0824     p.addParameter(<span class="string">'out'</span>, nan, @(x) ischar(x) || isnan(x));
0825     p.addParameter(<span class="string">'cols'</span>, 5, @isscalar);
0826     p.addParameter(<span class="string">'psize'</span>, 1.0, @isscalar);
0827     p.addParameter(<span class="string">'lon_rg'</span>, [], @isvector);
0828     p.addParameter(<span class="string">'lat_rg'</span>, [], @isvector);
0829     p.addParameter(<span class="string">'clims'</span>, <span class="string">'auto'</span>, @(x) isscalar(x) || isvector(x));
0830 
0831     p.parse(varargin{:});
0832     
0833     data   = p.Results.data;
0834     out    = p.Results.out;
0835     fcols  = p.Results.cols;
0836     psize  = p.Results.psize;
0837     lon_rg = p.Results.lon_rg;
0838     lat_rg = p.Results.lat_rg;
0839     clims  = p.Results.clims;
0840     
0841     ncols = size(data, 2);
0842     
0843     ps = load(<span class="string">'ps2.mat'</span>);
0844     ll = ps.lonlat;
0845     clear ps;
0846     
0847     <span class="keyword">if</span> ncols == 1
0848         fcols = 1;
0849         frows = 1;
0850     <span class="keyword">else</span>
0851         frows = ceil(sqrt(ncols) - 1);
0852         frows = max(1, frows);
0853         fcols = ceil(ncols / frows);
0854     <span class="keyword">end</span>
0855     
0856     <span class="keyword">if</span> isnan(out)
0857         h = figure();
0858     <span class="keyword">else</span>
0859         h = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
0860     <span class="keyword">end</span>
0861     
0862     <span class="keyword">for</span> ii = 1:ncols
0863         subplot_tight(frows, fcols, ii);
0864         scatter(ll(:,1), ll(:,2), psize, data(:,ii));
0865         caxis(clims);
0866         colorbar();
0867     <span class="keyword">end</span>
0868     
0869     <span class="keyword">if</span> ~isnan(out)
0870         saveas(h, out);
0871     <span class="keyword">end</span>
0872 <span class="keyword">end</span>
0873 
0874 <a name="_sub15" href="#_subfunctions" class="code">function [] = corr_phase(ifg, value)</a>
0875 
0876     [x, y] = ginput;
0877 
0878     load(<span class="string">'phuw_sb2.mat'</span>)
0879     load(<span class="string">'ps2.mat'</span>)
0880 
0881     ph_ifg = ph_uw(:, ifg);
0882     lon = lonlat(:, 1);
0883     lat = lonlat(:, 2);
0884 
0885     in = inpolygon(lon, lat, x, y);
0886 
0887     ph_ifg(in) = ph_ifg(in) + value;
0888 
0889     ph_uw(:, ifg) = ph_ifg;
0890 
0891     save(<span class="string">'phuw_sb2.mat'</span>, <span class="string">'ph_uw'</span>, <span class="string">'msd'</span>)
0892 <span class="keyword">end</span>
0893 
0894 <a name="_sub16" href="#_subfunctions" class="code">function [] = crop(varargin)</a>
0895 
0896     p = inputParser();
0897     p.FunctionName = <span class="string">'crop'</span>;
0898     p.addRequired(<span class="string">'lon_min'</span>, @isscalar);
0899     p.addRequired(<span class="string">'lon_max'</span>, @isscalar);
0900     p.addRequired(<span class="string">'lat_min'</span>, @isscalar);
0901     p.addRequired(<span class="string">'lat_max'</span>, @isscalar);
0902 
0903     p.parse(varargin{:});
0904     lon_min = p.Results.lon_min;
0905     lon_max = p.Results.lon_max;
0906     lat_min = p.Results.lat_min;
0907     lat_max = p.Results.lat_max;
0908     
0909     <span class="keyword">if</span> ~exist(<span class="string">'ps2_old.mat'</span>, <span class="string">'file'</span>)
0910         copyfile ps2.mat ps2_old.mat
0911     <span class="keyword">end</span>
0912 
0913     <span class="keyword">if</span> ~exist(<span class="string">'pm2_old.mat'</span>, <span class="string">'file'</span>)
0914         copyfile pm2.mat pm2_old.mat
0915     <span class="keyword">end</span>
0916 
0917     <span class="keyword">if</span> ~exist(<span class="string">'hgt2_old.mat'</span>, <span class="string">'file'</span>)
0918         copyfile hgt2.mat hgt2_old.mat
0919     <span class="keyword">end</span>
0920 
0921     <span class="keyword">if</span> ~exist(<span class="string">'bp2_old.mat'</span>, <span class="string">'file'</span>)
0922         copyfile bp2.mat bp2_old.mat
0923     <span class="keyword">end</span>
0924 
0925     <span class="keyword">if</span> ~exist(<span class="string">'rc2_old.mat'</span>, <span class="string">'file'</span>)
0926         copyfile rc2.mat rc2_old.mat
0927     <span class="keyword">end</span>
0928     
0929     ps = load(<span class="string">'ps2_old.mat'</span>);
0930     pm = load(<span class="string">'pm2_old.mat'</span>);
0931     bp = load(<span class="string">'bp2_old.mat'</span>);
0932     rc = load(<span class="string">'rc2_old.mat'</span>);
0933     hgt = load(<span class="string">'hgt2_old.mat'</span>);
0934     
0935     lon = ps.lonlat(:,1);
0936     lat = ps.lonlat(:,2);
0937     
0938     before = size(lon, 1);
0939     
0940     idx = ~(lon &gt; lon_min &amp; lon &lt; lon_max &amp; lat &gt; lat_min &amp; lat &lt; lat_max);
0941     
0942     after = sum(~idx);
0943     
0944     ps.xy(idx,:) = [];
0945     ps.lonlat(idx,:) = [];
0946     ps.ij(idx,:) = [];
0947     
0948     pm.coh_ps(idx,:) = [];
0949 
0950     hgt.hgt(idx,:) = [];
0951     
0952     rc.ph_rc(idx,:) = [];
0953     
0954     bp.bperp_mat(idx,:) = [];
0955     
0956     fprintf(<span class="string">'Number of datapoints before cropping: %e and after cropping: %e'</span>, <span class="keyword">...</span>
0957              before, after);
0958     
0959     save(<span class="string">'hgt2.mat'</span>, <span class="string">'-struct'</span>, <span class="string">'hgt'</span>);
0960     save(<span class="string">'bp2.mat'</span>, <span class="string">'-struct'</span>, <span class="string">'bp'</span>);
0961 
0962     save(<span class="string">'rc2.mat'</span>, <span class="string">'-struct'</span>, <span class="string">'rc'</span>);
0963     save(<span class="string">'pm2.mat'</span>, <span class="string">'-struct'</span>, <span class="string">'pm'</span>);
0964     
0965     save(<span class="string">'ps2.mat'</span>, <span class="string">'-struct'</span>, <span class="string">'ps'</span>);
0966 <span class="keyword">end</span>
0967 
0968 <a name="_sub17" href="#_subfunctions" class="code">function [] = crop_reset()</a>
0969     movefile ps2_old.mat ps2.mat
0970     movefile pm2_old.mat pm2.mat
0971     movefile hgt2_old.mat hgt2.mat
0972     movefile bp2_old.mat bp2.mat
0973     movefile rc2_old.mat rc2.mat
0974 <span class="keyword">end</span>
0975 
0976 <a name="_sub18" href="#_subfunctions" class="code">function [] = save_llh()</a>
0977     
0978     ps = load(<span class="string">'ps2.mat'</span>);
0979         
0980     llh = zeros(size(ps.lonlat, 1), 3);
0981     llh(:,1:2) = ps.lonlat;
0982     
0983     clear ps;
0984     
0985     hgt = load(<span class="string">'hgt2.mat'</span>);
0986     llh(:,3) = hgt.hgt;
0987     
0988     clear hgt;
0989     
0990     fid = <a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>(<span class="string">'llh.dat'</span>, <span class="string">'w'</span>);
0991     fwrite(fid, transpose(llh), <span class="string">'double'</span>);
0992     fclose(fid);
0993     
0994 <span class="keyword">end</span>
0995 
0996 <a name="_sub19" href="#_subfunctions" class="code">function [] = save_binary(varargin)</a>
0997     p = inputParser;
0998     p.FunctionName = <span class="string">'save_binary'</span>;
0999     
1000     check_data = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
1001                             {<span class="string">'nonempty'</span>, <span class="string">'finite'</span>, <span class="string">'ndims'</span>, 2});
1002     
1003     p.addRequired(<span class="string">'data'</span>, check_data);
1004     p.addRequired(<span class="string">'path'</span>, @ischar);
1005     p.addParameter(<span class="string">'dtype'</span>, <span class="string">'double'</span>, @ischar);
1006     
1007     p.parse(varargin{:});
1008     
1009     data  = p.Results.data;
1010     path  = p.Results.path;
1011     dtype = p.Results.dtype;
1012 
1013     ps = load(<span class="string">'ps2.mat'</span>);
1014     
1015     n_lonlat = size(ps.lonlat, 1);
1016     
1017     <span class="keyword">if</span> size(data, 1) ~= n_lonlat
1018         error(<span class="string">'data should have the same number of rows as lonlat'</span>);
1019     <span class="keyword">end</span>
1020     
1021     ll = zeros(n_lonlat, 2 + size(data, 2));
1022     ll(:,1:2) = ps.lonlat;
1023     clear ps;
1024     
1025     ll(:,3:end) = data;
1026     
1027     fid = <a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>(path, <span class="string">'w'</span>);
1028     fwrite(fid, transpose(ll), dtype);
1029     fclose(fid);
1030 <span class="keyword">end</span>
1031 
1032 <a name="_sub20" href="#_subfunctions" class="code">function loaded = load_binary(varargin)</a>
1033 
1034     p = inputParser();
1035     p.FunctionName = <span class="string">'load_binary'</span>;
1036     
1037     p.addRequired(<span class="string">'path'</span>, @ischar);
1038     p.addRequired(<span class="string">'ncols'</span>, @(x) isscalar(x) &amp; x &gt; 0.0 &amp; isfinite(x));
1039     p.addParameter(<span class="string">'dtype'</span>, <span class="string">'double'</span>, @ischar);
1040     
1041     p.parse(varargin{:});
1042     args = p.Results;
1043     
1044     fid = <a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>(args.path, <span class="string">'r'</span>);
1045     loaded = transpose(fread(fid, [args.ncols, Inf], args.dtype));
1046     fclose(fid);
1047 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 18-May-2018 14:32:08 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>