<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of traux</title>
  <meta name="keywords" content="traux">
  <meta name="description" content="TRAIN Axilliary functions.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">Matlab</a> &gt; traux.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Matlab&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>traux
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>TRAIN Axilliary functions.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function out = metin(fun, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> TRAIN Axilliary functions.

 Based on codes by David Bekaert and Andrew Hooper from packages TRAIN
 (https://github.com/dbekaert/TRAIN) and
 StaMPS (https://homepages.see.leeds.ac.uk/~earahoo/stamps/).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>	fid = sfopen(path, mode, machine)</li><li><a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>	StaMPS Auxulliary functions.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [out] = plot_2d_fft(varargin)</a></li><li><a href="#_sub2" class="code">function [butter] = butter_filter(varargin)</a></li><li><a href="#_sub3" class="code">function [abs_phase] = invert_abs(varargin)</a></li><li><a href="#_sub4" class="code">function [abs_phase] = invert_phase_stamps(varargin)</a></li><li><a href="#_sub5" class="code">function [corrected_phase] = subtract_dry()</a></li><li><a href="#_sub6" class="code">function [d_total] = total_aps(varargin)</a></li><li><a href="#_sub7" class="code">function [Z] = geopot2h(varargin)</a></li><li><a href="#_sub8" class="code">function [] = aps_setup(varargin)</a></li><li><a href="#_sub9" class="code">function [] = calc_wv(varargin)</a></li><li><a href="#_sub10" class="code">function [ret] = rms(data)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function out = metin(fun, varargin)</a>
0002 <span class="comment">% TRAIN Axilliary functions.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Based on codes by David Bekaert and Andrew Hooper from packages TRAIN</span>
0005 <span class="comment">% (https://github.com/dbekaert/TRAIN) and</span>
0006 <span class="comment">% StaMPS (https://homepages.see.leeds.ac.uk/~earahoo/stamps/).</span>
0007 <span class="comment">%</span>
0008 
0009     <span class="keyword">switch</span>(fun)
0010         <span class="keyword">case</span> <span class="string">'plot_2d_ftt'</span>
0011             out = <a href="#_sub1" class="code" title="subfunction [out] = plot_2d_fft(varargin)">plot_2d_fft</a>(varargin{:});
0012         <span class="keyword">case</span> <span class="string">'butter_filter'</span>
0013             out = buttter_filter(varargin{:});
0014         <span class="keyword">case</span> <span class="string">'subtract_dry'</span>
0015             out = <a href="#_sub5" class="code" title="subfunction [corrected_phase] = subtract_dry()">subtract_dry</a>(varargin{:});
0016         <span class="keyword">case</span> <span class="string">'invert_abs'</span>
0017             out = <a href="#_sub3" class="code" title="subfunction [abs_phase] = invert_abs(varargin)">invert_abs</a>(varargin{:});
0018         <span class="keyword">case</span> <span class="string">'invert_phase_stamps'</span>
0019             out = <a href="#_sub4" class="code" title="subfunction [abs_phase] = invert_phase_stamps(varargin)">invert_phase_stamps</a>(varargin{:});
0020         <span class="keyword">case</span> <span class="string">'zero_outlier'</span>
0021             out = zero_outlier(varargin{:});
0022         <span class="keyword">case</span> <span class="string">'total_aps'</span>
0023             out = <a href="#_sub6" class="code" title="subfunction [d_total] = total_aps(varargin)">total_aps</a>(varargin{:});
0024         <span class="keyword">case</span> <span class="string">'aps_setup'</span>
0025             <a href="#_sub8" class="code" title="subfunction [] = aps_setup(varargin)">aps_setup</a>(varargin{:})
0026         <span class="keyword">case</span> <span class="string">'geopot2h'</span>
0027             out = <a href="#_sub7" class="code" title="subfunction [Z] = geopot2h(varargin)">geopot2h</a>(varargin{:})
0028         <span class="keyword">case</span> <span class="string">'calc_wv'</span>
0029             <a href="#_sub9" class="code" title="subfunction [] = calc_wv(varargin)">calc_wv</a>(varargin{:})
0030         <span class="keyword">otherwise</span>
0031             error([<span class="string">'Unknown function '</span>, fun]);
0032     <span class="keyword">end</span>
0033 <span class="keyword">end</span>
0034 
0035 <a name="_sub1" href="#_subfunctions" class="code">function [out] = plot_2d_fft(varargin)</a>
0036     
0037     check_matrix = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0038                                 {<span class="string">'nonempty'</span>, <span class="string">'finite'</span>});
0039     
0040     p = inputParser;
0041     p.FunctionName = <span class="string">'plot_fft_2d'</span>;
0042     p.addRequired(<span class="string">'matrix_fft'</span>, check_matrix);
0043     p.addRequired(<span class="string">'out'</span>, @ischar);
0044     p.addParameter(<span class="string">'samp_rate'</span>, 1, check_matrix);
0045     p.addParameter(<span class="string">'logscale'</span>, false, @islogical);
0046     p.addParameter(<span class="string">'fftshift'</span>, true, @islogical);
0047     p.parse(varargin{:});
0048     
0049     args = p.Results;
0050     
0051     matrix = args.matrix_fft;
0052     
0053     nx = size(matrix, 2);
0054     ny = size(matrix, 1);
0055 
0056     samp_rate = p.Results.samp_rate;
0057     <span class="keyword">if</span> isscalar(samp_rate)
0058         samp_x = 1 / samp_rate;
0059         samp_y = 1 / samp_rate;
0060     <span class="keyword">else</span>
0061         samp_x = 1 / samp_rate(2);
0062         samp_y = 1 / samp_rate(1);
0063     <span class="keyword">end</span>
0064     
0065     <span class="keyword">if</span> samp_x &lt; 0.0 | samp_y &lt; 0.0
0066         error(<span class="string">'Sampling rate must be positive'</span>);
0067     <span class="keyword">end</span>
0068     
0069     x_fr = (-nx / 2 : nx / 2 - 1) * samp_x / nx;
0070     y_fr = (-ny / 2 : ny / 2 - 1) * samp_y / ny;
0071 
0072     h = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
0073     
0074     <span class="keyword">if</span> args.fftshift
0075         matrix = fftshift(matrix);
0076     <span class="keyword">end</span>
0077     
0078     <span class="keyword">if</span> args.logscale
0079         to_plot = log10(abs(matrix));
0080     <span class="keyword">else</span>
0081         to_plot = abs(matrix);
0082     <span class="keyword">end</span>
0083     
0084     imagesc(x_fr, y_fr, to_plot);
0085     colorbar();
0086     saveas(h, args.out);
0087     
0088     out.h = h;
0089     out.x_fr = x_fr;
0090     out.y_fr = y_fr;
0091 <span class="keyword">end</span>
0092 
0093 <a name="_sub2" href="#_subfunctions" class="code">function [butter] = butter_filter(varargin)</a>
0094 <span class="comment">% Adapted from StaMPS by Andy Hooper</span>
0095 
0096     p = inputParser();
0097     p.FunctionName = <span class="string">'butter_filter'</span>;
0098     check_matrix = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0099                                 {<span class="string">'nonempty'</span>, <span class="string">'positive'</span>, <span class="string">'finite'</span>}, <span class="string">'fft_2d'</span>);
0100     check_scalar = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0101         {<span class="string">'scalar'</span>, <span class="string">'positive'</span>, <span class="string">'finite'</span>}, <span class="keyword">...</span>
0102         <span class="string">'create_butterworth_filter'</span>);    
0103     
0104     p.addRequired(<span class="string">'matrix_size'</span>, check_matrix);
0105     p.addRequired(<span class="string">'low_pass_wavelength'</span>, check_scalar);
0106     p.addParameter(<span class="string">'order'</span>, 5, check_scalar);
0107     p.addParameter(<span class="string">'samp_rate'</span>, 1, check_matrix);
0108 
0109     p.parse(varargin{:});
0110     
0111     msize = p.Results.matrix_size;
0112     <span class="keyword">if</span> isscalar(msize)
0113         nx = msize;
0114         ny = msize;
0115     <span class="keyword">else</span>
0116         nx = msize(2);
0117         ny = msize(1);
0118     <span class="keyword">end</span>    
0119     
0120     low_pass_wavelength = p.Results.low_pass_wavelength;
0121     k0 = 1 / low_pass_wavelength;
0122     
0123     order = p.Results.order;
0124     
0125     samp_rate = p.Results.samp_rate;
0126     <span class="keyword">if</span> isscalar(samp_rate)
0127         samp_x = samp_rate;
0128         samp_y = samp_rate;
0129     <span class="keyword">else</span>
0130         samp_x = samp_rate(2);
0131         samp_y = samp_rate(1);
0132     <span class="keyword">end</span>
0133     
0134     kx = (-nx / 2 : nx / 2 - 1) * samp_x / nx;
0135     ky = (-ny / 2 : ny / 2 - 1) * samp_y / ny;
0136         
0137     [kx, ky] = meshgrid(kx, ky);
0138     
0139     k_dist = sqrt( kx.^2 + ky.^2 );
0140     
0141     butter = 1 ./ (1 + (k_dist ./ k0).^(2*order));
0142 <span class="keyword">end</span>
0143 
0144 <a name="_sub3" href="#_subfunctions" class="code">function [abs_phase] = invert_abs(varargin)</a>
0145 
0146     p = inputParser;
0147     p.FunctionName = <span class="string">'invert_abs'</span>;
0148 
0149     check_phase = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0150                                 {<span class="string">'nonempty'</span>, <span class="string">'finite'</span>, <span class="string">'ndims'</span>, 2});
0151     check_avg = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0152                                 {<span class="string">'nonempty'</span>, <span class="string">'vector'</span>, <span class="string">'finite'</span>});
0153     check_idx = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0154                                 {<span class="string">'scalar'</span>, <span class="string">'positive'</span>, <span class="string">'finite'</span>, <span class="string">'integer'</span>});
0155     
0156     p.addRequired(<span class="string">'phase'</span>, check_phase);
0157     p.addParameter(<span class="string">'last_row'</span>, 0.0, check_avg);
0158     p.addParameter(<span class="string">'master_idx'</span>, 1, check_idx);
0159     
0160     p.parse(varargin{:});
0161     
0162     phase      = p.Results.phase;
0163     master_idx = p.Results.master_idx;
0164     last       = p.Results.last_row;
0165     
0166     [n_ps, n_ifg] = size(phase);
0167     
0168     n_sar = n_ifg + 1;
0169     
0170     design = zeros(n_ifg, n_sar);
0171     design(:, master_idx) = 1.0;
0172     
0173     slaves = - diag(ones(n_ifg, 1));
0174     
0175     <span class="keyword">if</span> master_idx == 1
0176         design(:,2:end) = slaves;
0177     <span class="keyword">elseif</span> master_idx == n_sar
0178         design(:,1:end-1) = slaves;
0179     <span class="keyword">else</span>
0180         idx = master_idx - 1;
0181         design(1:idx, 1:idx) = slaves(1:idx, 1:idx);
0182         
0183         idx = master_idx + 1;
0184         design(master_idx:<span class="keyword">end</span>, idx:end) = slaves(master_idx:<span class="keyword">end</span>, master_idx:end);
0185     <span class="keyword">end</span>
0186     
0187     clear slaves;
0188     
0189     design = [design; ones(1, n_sar)];
0190     
0191     <span class="keyword">if</span> isscalar(last) &amp;&amp; last == 0.0
0192         phase = [phase'; zeros(1, n_ps)];
0193     <span class="keyword">else</span>
0194         <span class="keyword">if</span> iscolumn(last)
0195             phase = transpose([phase, last]);
0196         <span class="keyword">else</span>
0197             phase = [transpose(phase); last];
0198         <span class="keyword">end</span>
0199     <span class="keyword">end</span>
0200     
0201     abs_phase = lscov(design, double(phase));
0202 <span class="keyword">end</span>
0203 
0204 <a name="_sub4" href="#_subfunctions" class="code">function [abs_phase] = invert_phase_stamps(varargin)</a>
0205 
0206     p = inputParser;
0207     p.FunctionName = <span class="string">'invert_phase_stamps'</span>;
0208 
0209     check_avg = @(x) validateattributes(x, {<span class="string">'numeric'</span>}, <span class="keyword">...</span>
0210                                 {<span class="string">'nonempty'</span>, <span class="string">'vector'</span>, <span class="string">'finite'</span>});
0211     
0212     p.addParameter(<span class="string">'average'</span>, 0.0, check_avg);
0213     
0214     p.parse(varargin{:});
0215     
0216     ph = load(<span class="string">'phuw2.mat'</span>);
0217     ps = load(<span class="string">'ps2.mat'</span>);
0218     
0219     phase = ph.ph_uw;
0220     master_idx = ps.master_ix;
0221     
0222     clear ph ps;
0223  
0224     phase(:,master_idx) = [];
0225     
0226     abs_phase = <a href="#_sub3" class="code" title="subfunction [abs_phase] = invert_abs(varargin)">invert_abs</a>(phase, <span class="string">'master_idx'</span>, master_idx, <span class="keyword">...</span>
0227                            <span class="string">'average'</span>, p.Results.average);
0228 <span class="keyword">end</span>
0229 
0230 <a name="_sub5" href="#_subfunctions" class="code">function [corrected_phase] = subtract_dry()</a>
0231 
0232     ph_uw = load(<span class="string">'phuw2.mat'</span>);
0233     ph_uw = ph_uw.ph_uw;
0234     
0235     ph_tropo = load(<span class="string">'tca2.mat'</span>);
0236 
0237     corrected_phase = ph_uw - ph_tropo.ph_tropo_era_hydro;
0238 <span class="keyword">end</span>
0239 
0240 <a name="_sub6" href="#_subfunctions" class="code">function [d_total] = total_aps(varargin)</a>
0241 <span class="comment">% Based on the `aps_weather_model_InSAR` function of the TRAIN packege.</span>
0242     p = inputParser;
0243     p.FunctionName = <span class="string">'total_aps'</span>;
0244     p.addParameter(<span class="string">'outdir'</span>, <span class="string">'.'</span>, @ischar);
0245     
0246     p.parse(varargin{:});
0247     
0248     outdir = p.Results.outdir;
0249     
0250     <span class="comment">% radar wavelength in cm</span>
0251     lambda         = getparm_aps(<span class="string">'lambda'</span>, 1) * 100;
0252     ll_matfile     = getparm_aps(<span class="string">'ll_matfile'</span>,1);
0253     ifgday_matfile = getparm_aps(<span class="string">'ifgday_matfile'</span>);
0254     weather_model_datapath = getparm_aps(<span class="string">'era_datapath'</span>,1);
0255     
0256     <span class="comment">% Filename suffix of the output files</span>
0257     wetoutfile = <span class="string">'_ZWD.xyz'</span>;   
0258     hydroutfile = <span class="string">'_ZHD.xyz'</span>; 
0259     
0260     <span class="comment">% Filename suffix of the output files</span>
0261     outfile = <span class="string">'.ztd'</span>;
0262     
0263     <span class="comment">% assumed date structure for era</span>
0264     datestructure = <span class="string">'yyyymmdd'</span>;
0265     
0266     <span class="comment">% loading the data</span>
0267     fprintf(<span class="string">'Stamps processed structure \n'</span>)
0268     ps = load(ll_matfile);
0269     load psver
0270     dates = ps.day;
0271     lonlat = ps.lonlat;
0272     
0273     <span class="comment">%azi_inc = staux('load_azi_inc');</span>
0274     <span class="comment">%inc_angle = azi_inc(:,2);</span>
0275     
0276     <span class="comment">% getting the dropped ifgs</span>
0277     drop_ifg_index = getparm(<span class="string">'drop_ifg_index'</span>);
0278 
0279     <span class="comment">% getting the parms file list from stamps to see the final ifg list</span>
0280     <span class="keyword">if</span> strcmp(getparm(<span class="string">'small_baseline_flag'</span>),<span class="string">'y'</span>)
0281         sb_flag = 1;
0282     <span class="keyword">else</span>
0283         sb_flag = 0;
0284     <span class="keyword">end</span>
0285     
0286     n_ifg = ps.n_ifg;
0287     <span class="comment">% constructing the matrix with master and slave dates</span>
0288     <span class="keyword">if</span> sb_flag ==1
0289         <span class="comment">% for SB</span>
0290         ifg_number = [1:n_ifg]';
0291         ifgday_ix = ps.ifgday_ix;
0292         <span class="comment">% removing those dropped interferograms</span>
0293         ifgday_ix(drop_ifg_index,:) =[];
0294         ifg_number(drop_ifg_index)=[];
0295 
0296         <span class="comment">% defining ix interferograms for which the delay needs to be computed</span>
0297         ifgs_ix = [ifgday_ix ifg_number];
0298     <span class="keyword">else</span>
0299         <span class="comment">% slightly different for PS.</span>
0300         date_slave_ix = [1:n_ifg]';
0301         ifg_number = [1:n_ifg]';
0302 
0303         <span class="comment">% removing those interferograms that have been dropped</span>
0304         date_slave_ix(drop_ifg_index)=[];
0305         ifg_number(drop_ifg_index)=[];
0306 
0307         <span class="comment">% the master dates</span>
0308         date_master_ix = repmat(ps.master_ix,size(date_slave_ix,1),1);
0309 
0310         <span class="comment">% ix interferograms</span>
0311         ifgs_ix = [date_master_ix date_slave_ix ifg_number];
0312     <span class="keyword">end</span>
0313     
0314     n_dates = length(dates);
0315     InSAR_datapath = [<span class="string">'.'</span>];
0316     apsname = fullfile(InSAR_datapath, <span class="string">'tca'</span>, num2str(psver), <span class="string">'.mat'</span>);
0317     apssbname = fullfile(InSAR_datapath, <span class="string">'tca_sb'</span>, num2str(psver), <span class="string">'.mat'</span>);
0318 
0319     <span class="comment">%% loading the weather model data</span>
0320     <span class="comment">% initialisation</span>
0321     
0322     <span class="comment">% these are the SAR estimated tropospheric delays for all data</span>
0323     d_wet   = NaN([size(lonlat,1) n_dates]);
0324     d_hydro = NaN([size(lonlat,1) n_dates]);
0325     d_total = NaN([size(lonlat,1) n_dates]);
0326     flag_wet_hydro_used = <span class="string">'n'</span>;
0327 
0328     ix_no_weather_model_data = [];
0329     counter = 0;
0330 
0331     <span class="comment">% looping over the dates</span>
0332     <span class="keyword">for</span> k = 1:n_dates
0333         <span class="comment">% getting the SAR data and convert it to a string</span>
0334         date_str = datestr(ps.day(k,1), datestructure);
0335 
0336         <span class="comment">% filenames</span>
0337         model_filename_wet = fullfile(weather_model_datapath, date_str, <span class="keyword">...</span>
0338                                       [date_str, wetoutfile]);
0339         model_filename_hydro = fullfile(weather_model_datapath, date_str, <span class="keyword">...</span>
0340                                         [date_str, hydroutfile]);
0341         model_filename = fullfile(weather_model_datapath, date_str, <span class="keyword">...</span>
0342                                   [date_str, outfile]);
0343 
0344         <span class="comment">% checking if there is actual data for this date, if not just</span>
0345         <span class="comment">% leave NaN's in the matrix.</span>
0346         
0347         <span class="keyword">if</span> exist(model_filename_wet, <span class="string">'file'</span>) == 2
0348             flag_wet_hydro_used = <span class="string">'y'</span>;
0349             
0350             <span class="comment">% computing the dry delay</span>
0351             [xyz_input, xyz_output] = <span class="keyword">...</span>
0352                     load_weather_model_SAR(model_filename_hydro, double(lonlat));
0353             
0354             <span class="comment">% saving the data which have not been interpolated</span>
0355             d_hydro(:,k) = xyz_output(:,3);
0356             clear xyz_input xyz_output
0357             
0358             
0359             <span class="comment">% computing the wet delays</span>
0360             [xyz_input, xyz_output] = <span class="keyword">...</span>
0361                         load_weather_model_SAR(model_filename_wet, double(lonlat));
0362              
0363             <span class="comment">% saving the output data</span>
0364             d_wet(:,k) = xyz_output(:,3);
0365             clear xyz_output
0366             counter = counter+1;
0367         <span class="keyword">elseif</span> exist(model_filename, <span class="string">'file'</span>) == 2
0368             flag_wet_hydro_used = <span class="string">'n'</span>;
0369             
0370             <span class="comment">% this is the GACOS model file, will need to pass the model-type as</span>
0371             <span class="comment">% its grid-note</span>
0372             
0373             [xyz_input, xyz_output] = <span class="keyword">...</span>
0374                 load_weather_model_SAR(model_filename, double(lonlat), [], model_type);
0375             
0376             <span class="comment">% saving the output data</span>
0377             d_total(:,k) = xyz_output(:,3);
0378             clear xyz_output
0379             counter = counter+1;
0380         <span class="keyword">else</span>
0381             <span class="comment">% rejected list of weather model images</span>
0382             ix_no_weather_model_data = [ix_no_weather_model_data k];
0383         <span class="keyword">end</span>
0384         clear model_filename_hydro model_filename_wet date_str
0385     <span class="keyword">end</span>
0386     fprintf([num2str(counter) <span class="string">' out of '</span> num2str(n_dates) <span class="keyword">...</span>
0387               <span class="string">' SAR images have a tropospheric delay estimated \n'</span>])
0388 
0389 
0390     <span class="comment">%% Computing the type of delay</span>
0391     <span class="keyword">if</span> strcmpi(flag_wet_hydro_used,<span class="string">'y'</span>)
0392         d_total = d_hydro + d_wet;
0393     <span class="keyword">end</span>
0394 
0395     <span class="keyword">if</span> ~isnan(outfile)
0396         save(outfile, <span class="string">'d_total'</span>, <span class="string">'d_hydro'</span>, <span class="string">'d_wet'</span>, <span class="string">'-v7.3'</span>);
0397     <span class="keyword">end</span>
0398     
0399     <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'save_binary'</span>, d_total, fullfile(outdir, <span class="string">'d_total.dat'</span>));
0400     <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'save_binary'</span>, d_hydro, fullfile(outdir, <span class="string">'d_hydro.dat'</span>));
0401     <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'save_binary'</span>, d_wet,   fullfile(outdir, <span class="string">'d_wet.dat'</span>));
0402 
0403     <span class="comment">%% Converting the Zenith delays to a slant delay</span>
0404     <span class="comment">%if size(inc_angle, 2) &gt; 1 &amp;&amp; size(inc_angle, 1) == 1</span>
0405         <span class="comment">%inc_angle = inc_angle';</span>
0406     <span class="comment">%end</span>
0407     
0408     <span class="comment">%if size(inc_angle, 2) == 1</span>
0409         <span class="comment">%inc_angle = repmat(inc_angle, 1, size(d_total, 2));</span>
0410         <span class="comment">%if size(inc_angle, 1) == 1</span>
0411             <span class="comment">%inc_angle = repmat(inc_angle, size(d_total,1), 1);</span>
0412         <span class="comment">%end</span>
0413     <span class="comment">%end</span>
0414     
0415     <span class="comment">% d_total = d_total ./ cos(deg2rad(inc_angle));</span>
0416     <span class="comment">%% Converting the range delay to a phase delay</span>
0417     <span class="comment">% converting to phase delay.</span>
0418     <span class="comment">% The sign convention is such that ph_corrected = ph_original - ph_tropo*</span>
0419     <span class="comment">% d_total = -4 * pi ./ lambda .* d_total;</span>
0420 <span class="keyword">end</span>
0421 
0422 <a name="_sub7" href="#_subfunctions" class="code">function [Z] = geopot2h(varargin)</a>
0423 
0424     p = inputParser();
0425     p.FunctionName = <span class="string">'geopot2h'</span>;
0426     p.addRequired(<span class="string">'geopot'</span>, @ismatrix);
0427     p.addRequired(<span class="string">'latgrid'</span>, @ismatrix);
0428 
0429     p.parse(varargin{:});
0430     geopot = p.Results.geopot;
0431     latgrid = p.Results.latgrid;
0432     
0433     <span class="comment">% Convert Geopotential to Geopotential Height and then to Geometric Height</span>
0434     g0 = 9.80665;
0435     <span class="comment">% Calculate Geopotential Height, H</span>
0436     H = geopot./g0;
0437 
0438     <span class="comment">% map of g with latitude</span>
0439     g = 9.80616.*(1 - 0.002637.*cosd(2.*latgrid) + 0.0000059.*(cosd(2.*latgrid)).^2);
0440     <span class="comment">% map of Re with latitude</span>
0441     Rmax = 6378137; 
0442     Rmin = 6356752;
0443     Re = sqrt(1./(((cosd(latgrid).^2)./Rmax^2) + ((sind(latgrid).^2)./Rmin^2)));
0444 
0445     <span class="comment">% Calculate Geometric Height, Z</span>
0446     Z = (H.*Re)./(g/g0.*Re - H);
0447 <span class="keyword">end</span>
0448 
0449 <a name="_sub8" href="#_subfunctions" class="code">function [] = aps_setup(varargin)</a>
0450 
0451     p = inputParser();
0452     p.FunctionName = <span class="string">'aps_setup'</span>;
0453     p.addRequired(<span class="string">'lonlat_step'</span>, @isscalar);
0454 
0455     p.parse(varargin{:});
0456     lonlat_step = p.Results.lonlat_step;
0457     
0458     <span class="comment">% preprocessor type</span>
0459     preproc = getparm(<span class="string">'insar_processor'</span>);
0460 
0461     <span class="keyword">if</span> strcmp(preproc, <span class="string">'doris'</span>)
0462         <span class="comment">% open dem parameters file</span>
0463         dem_params = <a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>(<span class="string">'demparms.in'</span>, <span class="string">'r'</span>);
0464         dem_path = fgetl(dem_params);
0465     <span class="keyword">elseif</span> strcmp(preproc, <span class="string">'gamma'</span>)
0466         dem_params = <span class="string">'../dem/dem_seg.par'</span>;
0467         dem_path = <span class="string">'../dem/dem_seg_swapped.dem'</span>;
0468     <span class="keyword">else</span>
0469         error([<span class="string">'Unrecognized preprocessor '</span>, preproc]);
0470     <span class="keyword">end</span>
0471     
0472     <span class="comment">% get dem file path</span>
0473     setparm_aps(<span class="string">'demfile'</span>, dem_path);
0474     setparm_aps(<span class="string">'era_datapath'</span>, [pwd <span class="string">'/era'</span>]);
0475     setparm_aps(<span class="string">'merra_datapath'</span>, [pwd <span class="string">'/merra2'</span>]);
0476     setparm_aps(<span class="string">'gacos_datapath'</span>, [pwd <span class="string">'/gacos'</span>]);
0477     
0478     setparm_aps(<span class="string">'lambda'</span>, getparm(<span class="string">'lambda'</span>), 1);
0479     setparm_aps(<span class="string">'heading'</span>, getparm(<span class="string">'heading'</span>), 1);
0480     
0481     <span class="comment">% get dem file extension</span>
0482     [~, ~, ext] = fileparts(dem_path);
0483     
0484     <span class="comment">% creating rsc file if .dem is the file extension</span>
0485     <span class="keyword">if</span> strcmp(ext, <span class="string">'.dem'</span>)
0486         fprintf(<span class="string">'DEM extension is .dem, creating, .dem.rsc file\n'</span>);
0487         dem_rsc = <a href="sfopen.html" class="code" title="function [fid] = sfopen(path, mode, machine)">sfopen</a>([dem_path, <span class="string">'.rsc'</span>], <span class="string">'w'</span>);
0488         
0489         <span class="keyword">if</span> strcmp(preproc, <span class="string">'doris'</span>)
0490             <span class="comment">% printing dem parameters</span>
0491             fprintf(dem_rsc, [<span class="string">'WIDTH '</span>, fgetl(dem_params), <span class="string">'\n'</span>]);
0492             fprintf(dem_rsc, [<span class="string">'LENGTH '</span>, fgetl(dem_params), <span class="string">'\n'</span>]);
0493             fprintf(dem_rsc, [<span class="string">'X_FIRST '</span>, fgetl(dem_params), <span class="string">'\n'</span>]);        
0494             fprintf(dem_rsc, [<span class="string">'Y_FIRST '</span>, fgetl(dem_params), <span class="string">'\n'</span>]);
0495         
0496             <span class="comment">% x and y step size</span>
0497             step = fgetl(dem_params);
0498 
0499             fprintf(dem_rsc, [<span class="string">'X_STEP '</span>, step, <span class="string">'\n'</span>]);
0500             fprintf(dem_rsc, [<span class="string">'Y_STEP '</span>, <span class="string">'-'</span>, step, <span class="string">'\n'</span>]);
0501             fprintf(dem_rsc, [<span class="string">'FORMAT '</span>, fgetl(dem_params), <span class="string">'\n'</span>]);
0502             fclose(dem_params);
0503         <span class="keyword">elseif</span> strcmp(preproc, <span class="string">'gamma'</span>)
0504             <span class="comment">% printing dem parameters</span>
0505             fprintf(dem_rsc, [<span class="string">'WIDTH '</span>, num2str(readparm(dem_params, <span class="string">'width'</span>)), <span class="string">'\n'</span>]);
0506             fprintf(dem_rsc, [<span class="string">'LENGTH '</span>, num2str(readparm(dem_params, <span class="string">'nlines'</span>)), <span class="string">'\n'</span>]);
0507             fprintf(dem_rsc, [<span class="string">'X_FIRST '</span>, num2str(readparm(dem_params, <span class="string">'corner_lon'</span>)), <span class="string">'\n'</span>]);        
0508             fprintf(dem_rsc, [<span class="string">'Y_FIRST '</span>, num2str(readparm(dem_params, <span class="string">'corner_lat'</span>)), <span class="string">'\n'</span>]);
0509         
0510             fprintf(dem_rsc, [<span class="string">'X_STEP '</span>, num2str(readparm(dem_params, <span class="string">'post_lon'</span>)), <span class="string">'\n'</span>]);
0511             fprintf(dem_rsc, [<span class="string">'Y_STEP '</span>, num2str(readparm(dem_params, <span class="string">'post_lat'</span>)), <span class="string">'\n'</span>]);
0512             fprintf(dem_rsc, [<span class="string">'FORMAT '</span>, readparm(dem_params, <span class="string">'data_format'</span>), <span class="string">'\n'</span>]);
0513         <span class="keyword">end</span>
0514         fclose(dem_rsc);
0515     <span class="keyword">end</span>
0516     
0517     <span class="comment">% loading lonlat values, assuming processing was done by StaMPS</span>
0518     ps2 = load(<span class="string">'ps2.mat'</span>);
0519     lonlat = ps2.lonlat;
0520     clear ps2;
0521     
0522     setparm_aps(<span class="string">'region_lon'</span>, [min(lonlat(:,1)) - lonlat_step, <span class="keyword">...</span>
0523                                max(lonlat(:,1)) + lonlat_step]);
0524 
0525     setparm_aps(<span class="string">'region_lat'</span>, [min(lonlat(:,2)) - lonlat_step, <span class="keyword">...</span>
0526                                max(lonlat(:,2)) + lonlat_step]);    
0527 <span class="keyword">end</span>
0528 
0529 <a name="_sub9" href="#_subfunctions" class="code">function [] = calc_wv(varargin)</a>
0530     
0531     <span class="comment">%p = inputParser;</span>
0532     lambda = getparm_aps(<span class="string">'lambda'</span>, 1) * 100;
0533     
0534     ph = load(<span class="string">'phuw2.mat'</span>);
0535     ps = load(<span class="string">'ps2.mat'</span>);
0536     
0537     phase = ph.ph_uw;
0538     master_idx = ps.master_ix;
0539     phase(:,master_idx) = [];
0540     
0541     ncols = ps.n_image + 2;
0542     
0543     clear ps ph
0544     
0545     <span class="comment">% loading zenith delays</span>
0546     d_total = <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'load_binary'</span>, <span class="string">'d_total.dat'</span>, ncols);
0547     <span class="comment">% lon., lat. coordinates (first two columns) are not required</span>
0548     d_total = d_total(:,3:end);
0549     
0550     d_hydro = <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'load_binary'</span>, <span class="string">'d_hydro.dat'</span>, ncols);
0551     d_hydro = d_hydro(:,3:end);
0552     
0553     d_wet = <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'load_binary'</span>, <span class="string">'d_wet.dat'</span>, ncols);
0554     d_wet = d_wet(:,3:end);
0555     
0556     azi_inc = <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'load_binary'</span>, <span class="string">'azi_inc.dat'</span>, 2);
0557     inc_angle = azi_inc(:,2); clear azi_inc
0558     
0559     <span class="keyword">if</span> size(inc_angle, 2) &gt; 1 &amp;&amp; size(inc_angle, 1) == 1
0560         inc_angle = inc_angle';
0561     <span class="keyword">end</span>
0562     
0563     <span class="keyword">if</span> size(inc_angle, 2) == 1
0564         inc_angle = repmat(inc_angle, 1, size(d_total, 2));
0565         <span class="keyword">if</span> size(inc_angle, 1) == 1
0566             inc_angle = repmat(inc_angle, size(d_total, 1), 1);
0567         <span class="keyword">end</span>
0568     <span class="keyword">end</span>
0569     
0570     <span class="comment">% Converting the zenith delays to slant delays</span>
0571     d_total = d_total ./ cos(deg2rad(inc_angle));
0572     d_hydro = d_hydro ./ cos(deg2rad(inc_angle));
0573     <span class="comment">% phase = phase .* cos(deg2rad(inc_angle));</span>
0574     
0575     <span class="comment">%% Converting the range delay to a phase delay</span>
0576     <span class="comment">% The sign convention is such that ph_corrected = ph_original - ph_tropo*</span>
0577     
0578     <span class="comment">% d_total = -4 * pi ./ lambda .* d_total;</span>
0579     
0580     <span class="comment">% converting phase to delay</span>
0581     phase = - (lambda / (4 * pi))  .* phase;
0582 
0583     <span class="comment">% calculate average total delay for each SAR acquisition</span>
0584     <span class="comment">% d_avg = mean(d_total, 2);</span>
0585     d_sum = sum(d_total, 2);
0586     
0587     abs_phase = transpose(<a href="#_sub3" class="code" title="subfunction [abs_phase] = invert_abs(varargin)">invert_abs</a>(phase, <span class="string">'master_idx'</span>, master_idx, <span class="keyword">...</span>
0588                                      <span class="string">'last_row'</span>, d_sum));
0589     abs_wet = abs_phase - d_hydro;
0590     
0591     h = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
0592     hist(<a href="#_sub10" class="code" title="subfunction [ret] = rms(data)">rms</a>(abs_wet - d_wet));
0593     <span class="comment">%xlabel('Inverted water vapour slant delay [cm]');</span>
0594     <span class="comment">%ylabel('ERA water vapour slant delay [cm]');</span>
0595     saveas(h, <span class="string">'dinv_rms_wv.png'</span>);
0596 
0597     h = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
0598     hist(<a href="#_sub10" class="code" title="subfunction [ret] = rms(data)">rms</a>(abs_phase - d_total));
0599     <span class="comment">% xlabel('Inverted total slant delay [cm]');</span>
0600     <span class="comment">% ylabel('ERA total slant delay [cm]');</span>
0601     saveas(h, <span class="string">'dinv_rms_total.png'</span>);
0602     
0603     <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'save_binary'</span>, abs_phase, <span class="string">'dinv_total.dat'</span>);
0604     <a href="staux.html" class="code" title="function out = staux(fun, varargin)">staux</a>(<span class="string">'save_binary'</span>, abs_wet, <span class="string">'dinv_wet.dat'</span>);
0605 <span class="keyword">end</span>
0606 
0607 <a name="_sub10" href="#_subfunctions" class="code">function [ret] = rms(data)</a>
0608     ret = sqrt( mean(data.^2, 2) );
0609 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 18-May-2018 14:32:08 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>